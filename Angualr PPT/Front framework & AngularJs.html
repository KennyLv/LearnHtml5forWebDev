<!DOCTYPE html>
<!-- saved from url=(0051)http://html5ify.com/unittesting/slides/index.html#/ -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Javascript Framework & AngularJs</title>
		<meta name="author" content="Kenny">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">
		
		<link rel="stylesheet" href="css/style.css">
		
		<script type="text/javascript" src="./js/shBrushCore.js"></script>
		<script type="text/javascript" src="./js/shBrushJScript.js"></script>
		<link type="text/css" rel="stylesheet" href="./css/shBrushCoreDefault.css"/>
		<script type="text/javascript">
			SyntaxHighlighter.all();
		</script>

	</head>

	<body style="-webkit-transition: -webkit-transform 0.8s ease; transition: -webkit-transform 0.8s ease;">

		<div class="reveal zoom">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
					

				<section class="cover present" style="display: block;">
					<h1>Front Framework & AngularJs</h1>
					<h3>@Kenny</h3>
				</section>

				<section class="future" style="display: block;">
					<h2>Agenda</h2>
					<ul>
						<li>
							Front framework
						</li>
						<li>
							About AngularJS
							<!--
							(示例：baidu_map & 控件 & 天气插件 & qTips -- 想new几个new几个)
							估计是被忽悠了？ ---- 后面的代码很吓人啦！！
							好处 -- 不仅仅是MVC -- 工程化、开源（这个好处不用讲了，看看这个页面）
							-->
						</li>
						<li>
							First Look at AngularJs
							<!--
							基础知识（对MVC的实现）
							-->
						</li>
						<li>
							Little further on AngualrJs
							<!--
							- 深入实现（ 实现原理，实战）
							-->
						</li>
						<li>
							Q&A 
						</li>
					</ul>

				</section>

				
				<section class="future" style="display: none;" >
						<section>
							<h4>前言——Web开发与前端框架 (1)</h4>
									<!--
									我的学习过程分享ASP.NET -> Web Services & XML -> Restful & JSON ->
									-->
									
									<!--  富客户端
									
									Flex  [自己也是在学习中，不敢妄言，以后深入应用后再做补充] 
										1. Adobe平台的，基于ActionScript实现，用在哪都行，但偏重于内网管理系统，用在门户网站就相当于在线玩Flash游戏，loading... 
										2. 与Ext不同，它有健壮的可视化开发工具Flash Builder，可以同C#一样进行拖拽布局，生成一种xml，也便于维护。 
										3. 编译后生成swf文件直接嵌入html即可，提高安全性，浏览时同flash，需要flash player。 
										4. 与Ext相同，也是属于一个整体，有丰富的控件库。 
										5. 这条纯属个人观点，HTML5不支持插入对象，也就意味着不能插入swf文件，难道Flex就完蛋了？虽然HTML5不支持Flash是客观事实，但HTML5的统一为时尚远，各大浏览器对HTML5的支持，Adobe是否会有对策，这些会怎么样现在都不好说，HTML5与HTML4并行应该会有很长一段时间，至少Flex在现在是一个名列前茅的好产品，所以我选择了它。 

										SilverLight 
										微软平台的，主要是应用在微软系列的语言中，包括CS与BS架构。同样，
									
									-->
									<!--
									
									除了jQuery，Asp.net也不适合与以上等框架集成，因为Asp.net是事件驱动，这些框架都是为消息驱动而生的，勉强应用只会事倍功半，丧失.net本身的优势。 

									-->
							
						</section>
						<section>
							<h4>前言——Web开发与前端框架 (2)</h4>
								<!--
									jQuery 
									1. 绝对的万金油，核心js只有50K，占用带宽小，门户网站、管理系统，用在哪都可以。 
									3. 我认为它最大的三个亮点，
									一是支持CSS3的大量选择符，想定位或选择一个html元素简直轻而易举。
									二是灵活便捷的Ajax请求和回调操作。
									三是事件绑定功能，内部封装了很多事件，想统一为一个页面上的一些元素添加事件很方便，这也提高了复用性和可维护性，避免了页面中出现大量的html属性。
									合理的编码可以使html与js, css分离开，便于维护。 
									
									4. 此外它也封装了很多常用的操作，例如节点的添加删除、常用的动画效果、逻辑判断比较等等。避免了直接使用dom api进行繁琐的操作。 
									5. 本身提供了可扩展的函数，可以自己编写插件与核心jQuery对象进行集成使用。这也是常用的手段，只要你理解js面向对象编程，熟悉jQuery API，就能写出很多定制的插件，复用在各种地方。 
									
									8. 如果今后的更新都保持现在这种模式，我认为它的前景很乐观，什么时候javascript完蛋了才轮到它玩完。 
									
									 jQuery是对js底层dom操作封装最薄的一个框架，没有大量的专有对象，多为提供函数进行dom操作。
									 准确的说，它不是偏重于富客户端的框架，而是侧重于对js dom编程。
									 jQueryMobile以及jQueryUI的推出更，
									 jQueryUI与其他框架不一样的地方在于，它很少用js去生成html，而是把现有的html通过jQueryUI的API加工成想要的效果，关于这点是好是坏，我觉得就是见仁见智的问题了，没有必要争论什么。 
									新生的jQuery EasyUI不错。 
									 
									 
									 下面几种才是完整的富客户端的框架。 
									
									-->
									
						</section>
						<section>
							<h4>前言——Web开发与前端框架 (3)</h4>

									<!--
									交互
									
									框架演化 （）- > MV* -> 分工(EJS,YUI)
									-->
							
						</section>
						<section>
							<h4>前言——Web开发与前端框架 (4)</h4>

									<!--
									前端的挑战  http://www.zhihu.com/question/19984897
									-->
							
						</section>
				</section>


				<!--
				///////////////////////////////////////////// 基础 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1>First look @ AngularJs</h1>
				</section>
				
				
				<section class="future" style="display: none;">
						<h4>Fragmented Views</h4>
						<p>Hit the next arrow...</p>
						<div class="fragment"><code>any type</code></div>
						<div class="fragment"><em>of view</em></div>
						<div class="fragment">
								<fragment_tips >
								</fragment_tips>
						</div>
						<!--<ol>
							<li class="fragment"><code>any type</code></li>
							<li class="fragment"><em>of view</em></li>
							<li class="fragment"><strong>fragments</strong></li>
						</ol>-->
				</section>
					
					
				<section class="future" style="display: none;">
					<h4>About AngularJs</h4>
					<!--
						Example -- Hello world!
					-->
					<!--
						Modules -- Where our application components live.
						Directives --HTML annotations that trigger Javascript behaviors.
						Controllers -- Where we add application behavior.
						Expressions -- How values get displayed within the page.
					-->
					<!--
						Services
					-->
					
				</section>
				

				<section class="future" style="display: none;">
					<h4>Module</h4>
					
				</section>
				
				<section class="future" style="display: none;">
					<h4>Directive</h4>
					<!--
					Why use directives?
					-->
					<!--
					Attribute vs Elements directives
					-->
					
					<!--
					How to build a customer directives?
					-->
					
					<!--
						restrict: 'A',
						template
						link
						-->
						
						
				</section>
				
				<section class="future" style="display: none;">
					<h4>Controller</h4>
					
					<!--
					<img src="./img/controller.png"/>
						-->
						
				</section>
				
				<section class="future" style="display: none;">
					<h4>Scope</h4>
					<!--
					<img src="./img/model.png"/>
						-->
						
				</section>
				
				<section class="future" style="display: none;">
					<h4>View</h4>
					
					<!--
					
					http://www.cnblogs.com/lcllao/archive/2012/09/07/2671227.html
					<img src="./img/view.png"/>
					
					　view是用户所能看到的东西。view诞生于模版。它与model结合，最终呈现为浏览器DOM。Angular采取一个对于其他很多模版系统来说，很不一样的方式去呈现View。

					
					
其他模版引擎：很多模版引擎，是通过建立带有特殊标记的HTML字符串来实现的。通常这些模版标记破坏了HTML的语法，这意味着不能通过一般的HTML编辑器去编辑代码（这个嘛…）。模版字符串传入模版引擎，与数据合并。最终生成HTML字符串。这些字符串一般通过.innerHTML的方式写入DOM中，促使浏览器呈现模版内容。当数据发生改变时，这个过程需要一次又一次地重复。模版的粒度与DOM更新的粒度一致。这粒的关键，是模版系统处理字符串。
Angular：Angular模版的不同之处，在于它是基于DOM的而不是基于字符串的。模版依然需要在HTML中写入一些字符串，但依旧是HTML（不是通过在里面嵌入模版）。浏览器把HTML转换为DOM，然后DOM成为了compiler（angular的模版引擎）的输入。Compiler查找directives，依次在model中设置watches。得出的结果，是一个一直更新的view，不需要重新拼接model与template。model成为了view的唯一数据来源（single source of truth）。
 八、Directives
					
					-->
					
					
					<!--
					
					http://www.cnblogs.com/lcllao/archive/2012/09/04/2669802.html
					
					<img src="./img/oneway.png"/>
					<img src="./img/twoway.png"/>
					
					外面有许多模版系统，它们通常都通过模版字符串与数据进行连接，生成最终的HTML字符串，并将结果通过innerHTML属性写入某元素里。

					这意味着任何数据发生改变时，都需要重新将数据、模版合并成字符串，然后当作innerHTML写回对应元素中。这里存在一些问题：(这里直译实在没法懂..唯有YY)假设有这么一个场景，模版里包含输入框。用户对在输入框进行输入，模版同步更新。普通模版通过innerHTML、字符串与数据连接的方式更新视图，这样会打断用户的输入，体验不好。

　　Angular是与众不同的。Angular编译器（compiler）通过directives处理DOM，而不是通过处理字符串模版。处理结果是一个与scope model组合并生成实时模版的链接函数（linking function）。视图与scope model的绑定对我们来说是透明的。开发者无须为更新视图、model做任何动作。而且，因为没有使用innerHTML更新视图模版，所以用户输入不会被打断。此外，angular directives不仅可以绑定文本值，而且还可以是拥有行为的结构（behavioral constructs）。

　　Angular的这个处理方式，产生了一个稳定的DOM。这意味着在DOM元素的生命周期里，一直与某model的实例绑定着，这个关系不会发生改变。这也意味着代码可以保持对某DOM对象的引用，对其注册事件函数，并且这个引用不会被模版数据合并所销毁。
					
					-->
					
					
					<!--
					ng-src
					-->
					<!--
					ng-repeat
					-->
				</section>

				<section class="future" style="display: none;">
					<h4>Expression</h4>
					<!--
					{{}}
					-->
				</section>

				
				
				<section class="future" style="display: none;">
					<h4>filter</h4>
					<!--
					
					Arrayify
					Transforms a Map into an array so that the map can be used with ng-repeat.

					Currency
					Formats a number as a currency (for example $1,234.56).

					Date
					Formats a date value to a string based on the requested format.

					Filter
					Selects a subset of items from the provided List and returns it as a new List.

					FormatterModule
					This module registers all the Angular formatters.

					Json
					Converts an object into a JSON string.

					LimitTo
					Creates a new List or String containing only a prefix/suffix of the elements.

					Lowercase
					Converts a string to lowercase.

					Number
					Formats a number as text.

					OrderBy
					Orders the the elements of an Iterable using a predicate.

					Stringify
					Converts an object to a string.

					Uppercase
					Converts a string to uppercase.
					-->
					
					
					<!--
					basic filters
					-->
					
					<!--
					Linky
					$scope.contents = 'Text with links: http://angularjs.org/ & mailto:us@there.org';
					
					<div ng-bind-html="contents"></div>
					Text with links: http://angularjs.org/ & mailto:us@there.org
					
					<div ng-bind-html="contents | linky"></div>
					The linky filter goes through the text contents and adds <a> tags to all URLs and mailtolinks it finds, thus providing HTML content that the user can interact with:
					Text with links: http://angularjs.org/ & us@there.org
					-->
			
					
				</section>
				
				<section class="future" style="display: none;">
					<h4>事件处理</h4>
					
				</section>
				
				<section class="future" style="display: none;">
					<h4>路由与多视图</h4>
					<!--
					http://scotch.io/tutorials/javascript/single-page-apps-with-angularjs-routing-and-templating
					
					-->
				</section>
				
				
				<section class="future" style="display: none;">
					<h4>Service</h4>
					
						<!--
						why need a service?
						-->
						<!--
						How does Controller use a service?
						-->
						
						<!-- Example : 
						$http 
						-->
						
						<!--
						Dependency Injection!
						-->
						
					<!--
					How to build a customer Service?
					-->
					
						<!--
						$http
						$timeout
						$log
						$provider
						$inject

						-->
						
						
				</section>
				
				
				<section class="future" style="display: none;">
					<h4>Form</h4>
					
					<!--
					two-way binding
					-->
					<!--
					validate
					-->
				</section>
				
				
				<section class="future" style="display: none;">
					<h4>File Upload in AngularJS</h4>
					
				</section>
				
				<!--
				///////////////////////////////////////////// 深入 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1>Diving Deep with AngularJs</h1>
				</section>
				

				<section class="future" style="display: none;">
					<h4>How AngularJS Starts up in your browser?</h4>
				
				<!--
				
				<img src="./img/startup.png"/>
				
				下面描述angular是如何启动的（参考图表与下面的例子）：

					1. 浏览器加载HTML，将HTML标签转换为DOM对象；

					2. 浏览器加载angular.js的脚本；

					3. Angular等待DOMContentLoaded事件；

					4. Angular寻找ng-app这个用于指定应用边界范围的directive；

					5. 如果ng-app有指定module（也许是ng-app=”SomeApp”），将被用作配置$injector；

					6. $injector用于创建$compile服务（service）以及$rootScope；

					7. $compile服务用作“编译”（有点像遍历，然后做一点神秘的事情）DOM，并将其与对应的$rootScope连接。

					8. ng-init 这个directive在对应的scope中创建name属性并对其赋予”Kitty”值；

					9. 将“{{name}}”的值插入(interpolates)到表达式中，最终显示”Hello Kitty!”。


			<pre>
					<html lang="zh-cn" ng-app>
					<head>
						<meta charset="UTF-8">
						<title>Hello Kitty!</title>
						<style type="text/css">
							.ng-cloak {
								display: none;
							}
						</style>
					</head>
					<body>
					<div ng-init="name='Kitty'">Hello {{name}}!</div>
					<script src="../angular-1.0.1.js" type="text/javascript"></script>
					</body>
					</html>
			</pre>
-->
				
				</section>
				
					
				<section class="future" style="display: none;">
					<h4>ng运行与指令</h4>
					<!---
				ng-app指令：
				<html lang="en" ng-app>
				ng-app指令标记了AngularJS脚本的作用域，在<html>中添加ng-app属性即说明整个<html>都是AngularJS脚本作用域。开发者也可以在局部使用ng-app指令，如<div ng-app>，则AngularJS脚本仅在该<div>中运行。
					-->
					
					<!--
					angular指令的compile的参数(tElement,tAttrs)和link中的参数(scope,iElement,iAttrs)究竟有什么区别?
					http://segmentfault.com/q/1010000000664866
					
					ng指令中的compile与link函数解析
					http://www.ifeenan.com/angularjs/2014-09-04-%5B%E8%AF%91%5DNG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/
					-->
					
					<!--
					
					Compiler作为Angular的一个服务（Service），负责遍历DOM结构，寻找属性。编译过程分成两个阶段：

　　1. 编译（Compile）：遍历DOM节点树，收集所有directives。返回结果是一个链接函数（linking function）。

　　2. 链接（Link）：将directives绑定到一个作用域（scope）中，创建一个实况视图（live view）。在scope中的任何改变，将会在视图中得到体现（更新视图）；任何用户对模版的活动（改变），将会体现在scope model中（双向绑定）。这使得scope model能够反映正确的值。

　　一些directives，诸如ng-repeat，会为每一个在集合（collection）中的元素复制一次特定的元素（组合）。编译和链接两个阶段，使性能得以提升。因为克隆出来的模版(template)只需要编译一次，然后为每一个集合中的元素进行一次链接（类似模版缓存）。

					-->
					
					
					<!--
link: function(scope, element, attrs) {
var optionsObj = {
dataType: 'json'
};
if (scope.done) {
optionsObj.done = function() {
scope.$apply(function() {
scope.done({e: e, data: data});
});
};
}
if (scope.progress) {
optionsObj.progress = function(e, data) {
scope.$apply(function() {
scope.progress({e: e, data: data});
});
}
}
// the above could easily be done in a loop, to cover
// all API's that Fileupload provides
element.fileupload(optionsObj);
}-->
				</section>

				
				<section class="future" style="display: none;">
					<h4>AngularJS Runtime -- To $apply, or Not to $apply?</h4>
					<!--
					http://www.sitepoint.com/understanding-angulars-apply-digest/
					-->
					<!--
					To $apply, or Not to $apply?
There is confusion amongst AngularJS developers about when $scope.$apply() should
be called and when it shouldn’t. Recommendations and rumors on the Internet are
rampant. This section will make it crystal clear.
But first, let us try to put $apply in a simpler form.
Scope.$apply is like a lazy worker. It is told to do a lot of work, and it is responsible for
making sure that the bindings are updated and the view reflects all those changes. But
rather than doing this work all the time, it does it only when it feels it has enough work
to be done. In all other cases, it just nods, and notes the work for later. It only actually
does the work when you get its attention and tell it explicitly to work. AngularJS does
this internally at regular intervals within its lifecycle, but if the call comes from outside
(say a jQuery UI event), scope.$apply just takes note, but does nothing. That is why
we have to call scope.$apply to tell it, “Hey! You need to do this right now, and not
wait!”
Here are four quick tips about when (and how) to call $apply.

• DO NOT call it all the time. Calling $apply when AngularJS is happily ticking away
(in its $digest cycle, as we call it) will cause an exception. So “better safe than sorry”
is not the approach you want to use.
• DO CALL it when controls outside of AngularJS (DOM events, external callbacks
such as jQuery UI controls, and so on) are calling AngularJS functions. At that
point, you want to tell AngularJS to update itself (the models, the views, and so on),
and $apply does just that.

• Whenever possible, execute your code or function by passing it to $apply, rather
than executing the function and then calling $apply(). For example, execute the
following code:
$scope.$apply(function() {
$scope.variable1 = 'some value';
executeSomeAction();
});
instead of the following:
$scope.variable1 = 'some value';
executeSomeAction();
$scope.$apply();
While both of these will have the same effect, they differ in one significant way.

The first will capture any errors that happen when executeSomeAction is called, while
the latter will quietly ignore any such errors. You will get error notifications from AngularJS
only when you do the first.

• Consider using something like safeApply:
$scope.safeApply = function(fn) {
var phase = this.$root.$$phase;
if(phase == '$apply' || phase == '$digest') {
if(fn && (typeof(fn) === 'function')) {
fn();
}
} else {
this.$apply(fn);
}
};
You can monkey patch this into the topmost scope or the rootscope, and then use the
$scope.$safeApply function everywhere. This has been under discussion, and hopefully
in a future release, this will be the default behavior.

					-->
				</section>
				
				<section class="future" style="display: none;">
					<h4>Modules and the Injector</h4>
				
					<!--
					http://www.cnblogs.com/lcllao/archive/2012/09/07/2671227.html
					
					<img src="./img/Module & Injector.png"/>
				Injector是一个服务定位器。每一个Angular应用，都会有一个单独的injector。Injector提供一个通过名称查找对象实例的途径。Injector会在内部cache中保持所有对象实例，所以重复调用相同的名称时，返回的都是同一个对象实例。如果对象不存在，那么它会请求实例工厂（instance factory）去创建一个新实例。
				
				　Module是一个配置injector的实例工厂的方法，被称为”provider”。
				
				但是injector的真正牛X的地方在于它可以用于调用方法和”instantiate” type。这个美妙的特性是允许method和types请求他们所依赖的资源，而不是寻找他们。

 注意，我们唯一需要写的，就是我们的function，在function的arguments中列出方法依赖的资源即可！当angular调用function时，他会使用”call”方法，自动填充function agruments。

　　留意下面的例子中是如何在constructor中列出依赖的。当ng-controller实例化controller时，将自动提供所依赖的资源。没有必要去创建、寻找、创建injector引用来加载依赖资源。
				
				-->
				
				
				
				</section>
				
				<section class="future" style="display: none;">
					<h4>Event Loop</h4>
					
					<!--
					<img src="./img/startup.png"/>
这图表和后面的例子，描述了angular如何通过浏览器event-loop（所有的时间处理函数，以及timer执行的函数，会排在一个queue结构中，利用一个无限的循环，不断从queue中取出函数来执行，这个就是event-loop。来自http://wiki.nodejs.tw/nodejs_from_scratch/javascript-yunodejs/2-1-event-loop）来进行交互。

　　1. 浏览器event-loop等待事件到来。事件来自于用户交互（DOM events）、timer事件（setTimeout）、network事件（服务端响应，XHR之类）；

　　2. 事件回调函数开始执行。这里进入javascript上下文（context）。这回调函数可以修改DOM结构。

　　3. 当回调函数执行完毕后，浏览器退出javascript context，根据DOM的改变来重绘视图。

　　Angular通过创建自己的事件处理循环（event processing loop），修改了一般的javascript流（flow）。这将Javascript分割成传统的和Angular的执行上下文（execution context）。只要是在Angular execution context 里面执行的操作，都拥有angular data-binding、异常处理（exception handling）、属性监视（property watching）等能力。我们可以通过在javascript使用$apply()，进入Angular execution context。但要记住一点，在大多数（angular的）地方（如controllers、services），处理事件的directive会为你调用$apply。手动调用$apply的场景，一般是当你实现自定义事件处理函数，或者处理第三方库的回调的时候。

　　1. 通过调用scope.$apply(stimulusFn)进入angular execution context。stimulusFn就是我们想在angular execution context中执行的函数（含scope作为参数）或者angular合法的表达式。

　　2. Angular执行stimulusFn，这通常会改变应用的状态（application state）。

　　3. Angular进入$digest loop。这个loop由一个处理$evalAsync queue 和处理$watch list两个更小的循环组成。$digest loop会在model稳定之前保持迭代，即$evalAsync queue为空，而且$watch list没有检测到任何变化。

　　4. $evalAsync queue被用作安排必须跳出当前堆栈帧（堆栈帧指的是在堆栈中为当前正在运行的函数分配的区域（或空间）。传入的参数、返回地址（当这个函数结束后必须跳转到该返回地址。译注：即主调函数的断点处）以及函数所用的内部存储单元（即函数存储在堆栈上的局部变量）都在堆栈帧中。http://book.51cto.com/art/200804/70915.htm C.1.1  堆栈帧）之外，但在浏览器视图绘制之前的工作。这通常是通过使用setTimeout(0)来实现。但setTimeout(0)这方法，会导致缓慢，或者在每个事件处理完毕后，浏览器绘制视图时，出现视图闪烁（angular有没有去解决这个问题？如何解决？）。

　　5. $watch list是有可能在最近一次迭代中被修改的表达式的集合。如果(model)发生了改变，那么$watch 函数会被调用，从而达到对特定的DOM重新赋值的目标。

　　6. 一旦Angular $digest loop 完成了（之前3提到的情况），离开angular和javascript的context后，浏览器紧跟着就会去重绘DOM，以响应变化。

　　下面解释例子“Hello Kitty”(-_-!)是如何在用户在文本框输入文本时实现数据绑定(data-binding)效果。

　　1. 编译阶段(compilation phase)：

　　　　a) ng-model和input directive在<input>中版定keydown事件监听器。

　　　　b) {{name}}占位符（interpolation，不知道怎么翻译）（表达式）设置一个$watch以便在name发生改变时有所响应。

　　2. 执行阶段(runtime phase)：

　　　　a) 在inut控件中按下”X”按钮，让浏览器触发一个keydown事件；

　　　　b) input directive捕捉到文本框值的改变，然后调用$apply(“name = ‘X’;”)，在angular execution context中更新应用的model。

　　　　c) Angluar将 “name = ‘X’;”应用在model中。(model发生改变)

　　　　d) $digest loop开始

　　　　e) $watch list检测到name的值被改变了，然后再次解析{{name}}表达式，然后更新DOM。

　　　　f) Angulart退出(angular) execution context，再依次退出keydown事件以及javascript execution context；

　　　　g) 浏览器重绘视图，更新字符。

<pre>
<html lang="zh-cn" ng-app>
<head>
    <meta charset="UTF-8">
    <title>Hello Kitty!</title>
    <style type="text/css">
        .ng-cloak {
            display: none;
        }
    </style>
</head>
<body>
    <input ng-model="name" class="ng-cloak"/>
    <p>Hello {{name}}!</p>
<script src="../angular-1.0.1.js" type="text/javascript"></script>
</body>
</html>
</pre>
-->
					
				</section>
				
				<section class="future" style="display: none;">
					<h4>Diving Deep with Dependency Injection</h4>
				</section>
				
				<section class="future" style="display: none;">
					<h4>Diving deep into the AngularUI Router</h4>
				</section>

				<section class="future" style="display: none;">
					<h4>The Teams List App: Filtering and Controller Communication</h4>
					<!--
					In this example, we tackle multiple things at the same time, but there are two major takeaways(经验教训):
					1. How do you use filters—especially in a clean, simple way—with repeaters?
					2. How do you communicate between controllers that do not share an inheritance relation?
					-->

		
					<!--
					The Search Box
					filterService.searchText
					
					The Combo Boxes
					filterService.activeFilters.sports or city (depending on the box),

					The Check Box
					filterService.activeFilters.featured
					
					The Repeater
					"team in teamsList | filter:filterService.activeFilters | filter:filterService.searchText"

					-->

				</section>
				
				<section class="future" style="display: none;">
					<h4>Communicating Between Scopes with $on, $emit, and$broadcast</h4>
				</section>
				
				
				<section class="future" style="display: none;">
					<h4>$http and promise</h4>
					
						<!-- 
						$http with promise Working with Servers and Login
						-->
						
						<!-- 
						Additional $http functionality
						-->
						
						
				</section>
				
				<section class="future" style="display: none;">
					<h4>Internationalization and Localization</h4>
					<!--
					AngularJS supports i18n/L10n for the following filters out of the box:
• currency
• date/time
• number
There is also pluralization support (for English as well as i18n/L10n) with the ngPlur
alize directive.
All of this pluralization support is handled and managed by the $locale service, which
manages the locale-specific rule sets. The $locale service works off of locale IDs, which
generally consist of two parts: the country code and the language code. For example,
en_US and en_UK, denote English used in the US and the UK, respectively. Specifying a
country code is optional, just specifying “en” is a valid locale code.

1,Index.html changes
AngularJS requires you to have a separate index.html for each supported locale.
Your server also needs to know which index.html it has to provide, depending on
the user’s locale preferences (this could also be triggered from a client-side change,
when the user changes his locale).

2,Creating localized rule sets
The next step is creating an angular.js file for each supported locale, like
(angular_en-US.js and angular_zh-CN.js). This involves concatenating the
localization rules for each particular language (the default files for the preceding
two locales would be angular-locale_en-US.js and angular-locale_zh-CN.js) at the
end of the angular.js or the angular.min.js file. So your angular_en-US.js would
contain the contents of angular.js first, followed by the contents of the angularlocale_en-US.js.

3,Sourcing the localized rule sets
The final step involves ensuring that your localized index.html refers to the localized
rule set instead of the original angular.js file. So index_en-US.html should use
angular-en_US.js and not angular.js.

NOTE : 
•Translation Length
When internationalizing your apps, keep in mind that the lengths of your strings
might change drastically from language to language. Design your CSS accordingly,
and do thorough testing across the various languages. (Don’t forget that right to left
languages also exist!  <a herf="http://www.ibm.com/developerworks/cn/web/1404_xiayin_bidihtml/index.html">Introduction to bidirectional languages</a>)
•Timezones
The AngularJS date/time filter picks up the timezone settings from the browser. So
depending on the timezone of the computer, different people might see different
information. Neither JS nor AngularJS have any built-in support to display time
with a timezone specified by the developer


-->

				</section>

				
				<section class="future" style="display: none;">
					<h4>代码美化与规范</h4>
					<!--
					Module的分离与合并？ controller的分离与合并
					-->
					
					<!--
					依赖$injection的顺序
					-->
					
					<!--
					someModule.controller('MyController', function($scope, dep1, dep2) {
					  ...
					  $scope.aMethod = function() {
						...
					  }
					  ...
					});
					压缩之后若是修改了函数的参数名称会导致它不能注入依赖。那么可以改用 Array 的方式声明

						someModule.controller('MyController', ['$scope', 'dep1', 'dep2', 
													   function($scope,   dep1,   dep2) {
						  ...
						  $scope.aMethod = function() {
							...
						  }
						  ...
						}]);
						这样代码压缩就不会有问题了
						
						-->
						
						<!--
						现在我遇到这样一个问题，使用seajs配合angularjs，每个controller都写成了一个模块文件，再我最终部署的时候，我应该压缩合并这些controller了吗？
						seajs有相应的对angularjs的解决方案吗？ https://github.com/seajs/seajs/issues/555
						-->
						
						<!--
						How should I organize my modules? 
						-->
						
						<!--
							Angular Namespace
					为了防止名称冲突，angular会在object的名称中加入前缀$。请不要在代码中使用$前缀以避免冲突。(-_-!! )
						-->
						
				</section>

				
				<section class="future" style="display: none;">
					<h4>Using jQuery</h4>
				

				</section>

				<section class="future" style="display: none;">
					<h4>Using Socket.IO</h4>
				</section>

				
				<section class="future" style="display: none;">
					<h4>How to implement a UT</h4>
					<!--Pagination Service with unit test-->
					
					<!--
					基于AngularJS的项目被预先配置为使用JsTestDriver来运行单元测试。
					你可以像下面这样运行测试：
							在一个单独的终端上，进入到angular-phonecat目录并且运行./scripts/test-server.sh来启动测试（Windows命令行下请输入.\scripts\test-server.bat来运行脚本，后面脚本命令运行方式类似）；
							打开一个新的浏览器窗口，并且转到http://localhost:9876 ；
							选择“Capture this browser in strict mode”。
					这个时候，你可以抛开你的窗口不管然后把这事忘了。JsTestDriver会自己把测试跑完并且把结果输出在你的终端里。
					运行./scripts/test.sh进行测试 。你应当看到类似于如下的结果：
							Chrome: Runner reset.
							Total 1 tests (Passed: 1; Fails: 0; Errors: 0) (2.00 ms)
							Chrome 19.0.1084.36 Mac OS: Run 1 tests (Passed: 1; Fails: 0; Errors 0) (2.00 ms)
					耶！测试通过了！或者没有... 注意：如果在你运行测试之后发生了错误，关闭浏览器然后回到终端关了脚本，然后在重新来一边上面的步骤。
					-->
					
					
				</section>
				

				<section class="future" style="display: none;">
					<h4>总结</h4>
					<ul>
						<li>
						Angular 编程思想 http://www.oschina.net/translate/the-angular-way?print
						
						http://www.zhihu.com/question/21151483
						AngularJS 胜在可用和易于测试这两方面。
						<!--
						debug 麻烦
							AngularJS 给出的调用链又深、又难理解。

							另外还有两个可以注意的旧版本问题，最近新版本已经解决（还没发布到 bower）：
							- $resource 对 promise 的支持；$resource 功能稍弱.缺少很多必要的 HTTP 方法，需要自定义；缺少全局配置；内部 $http 的 PATCH 方法对低版 IE 不兼容；
							- directive 对动画的支持；
						-->
						</li>
					</ul>

				</section>

				<section class="future" style="display: none;">
					<h4>Q &amp; A</h4>
					<div>Thanks</div>
					<ol>
							<li><a href="http://www.cnblogs.com/lcllao/archive/2012/10/18/2728787.html">AngularJs学习笔记--Guide教程系列文章索引</a></li>
							<li><a href="http://www.ng-newsletter.com/">ng-newsletter</a></li>
							<li><a href="http://angularjs.cn/T001">AngularJs中文社区</a></li>
							<li><a href="http://woxx.sinaapp.com/">用AngularJS开发下一代Web应用</a></li>
							
					</ol>
				</section>

				<section class="future" style="display: none;">
					<h4>TODO 击鼓传花 -- 未接之谜</h4>
					<ul>
						<li>
							<span>AngularJs 日志输出</span>
							<span>如何对Directive/Service做单元测试？</span>
							<span>如何对AngularJs做测试？</span>
						</li>
						<li>
							<span>AngularJ项目代码的组织</span>
							<span>如何实现工程化？</span>
						</li>
					</ul>

				</section>
				
				<section class="future" style="display: none;">
						<svg width="800px" height="600px">
								<path id="my_path" d="M 20,260 C 40,180 80,180 100,260"  />
								<text>
										<textPath xlink:href="#my_path">如何实现工程化？</textPath>
								</text>
						</svg>
				</section>

			</div>
			
			<div class="progress" style="display: block;">
				<span style="width: 0px;"></span>
			</div>
			<aside class="controls" style="display: block;">
				<div class="left"></div>
				<div class="right enabled"></div>
				<div class="up"></div>
				<div class="down"></div>
			</aside>
			<aside class="clcok" style="display: block;">
					<!-- TODO -->
			</aside>
			<div class="state-background"></div>
			<div class="pause-overlay"></div>
		</div>

		<script src="js/head.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>
		// Full list of configuration options available here:
		// https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
		controls : true,
		progress : true,
		history : true,
		mouseWheel: false,
		overview: true,
		keyboard : true,
		rollingLinks : true,
		slideNumber: true,
		theme : Reveal.getQueryHash().theme, // available themes are in /css/theme
		transition : Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none
			
		// Optional libraries used to extend on reveal.js
		dependencies : [{
		src : 'js/plugin/classList.js',
		condition : function() {
		return !document.body.classList;
		}
		}, {
		src : 'js/plugin/showdown.js',
		condition : function() {
		return !!document.querySelector('[data-markdown]');
		}
		}, {
		src : 'js/plugin/markdown.js',
		condition : function() {
		return !!document.querySelector('[data-markdown]');
		}
		}, {
		src : 'js/plugin/zoom.js',
		async : true,
		condition : function() {
		return !!document.body.classList;
		}
		}, {
		src : 'js/plugin/notes.js',
		async : true,
		condition : function() {
		return !!document.body.classList;
		}
		}]
		});
		</script>

		<script type="text/javascript" src="js/plugin/zoom.js"></script>
		<script type="text/javascript" src="js/plugin/notes.js"></script>
		
		
		<!--
		TODO : ng-click="showPic(startUp)";
		-->
		
		<!--
		TODO : fragment_tips
		-->
		
		<div class="img_popup"> <img src="./img/startup.png"/> </div>
	</body>
</html>