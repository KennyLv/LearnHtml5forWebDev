<!--Using Resolve In AngularJS Routeshttp://www.tuicool.com/articles/YRVRVn http://odetocode.com/blogs/scott/archive/2014/05/20/using-resolve-in-angularjs-routes.aspx?utm_source=tuicoolA Better $state.reload for the AngularJS UI-Routerhttp://www.tuicool.com/articles/bq6VBr--><h1>AngularJS  的路由机制</h1>		<section  ng-show="currentShow == '0'">			<h3>AngularJS路由功能是一个纯前端的解决方案</h3>			<p>后台路由，通过不同的URL会路由到不同的控制器上(controller)，再渲染(render)到页面(HTML)。</p>			<p style="color:red;">AngularJS的前端路由，需求提前对指定的(ng-app)定义路由规则(routeProvider)，然后通过不同的URL，告诉(ng-app)加载哪个页面(HTML)，再渲染到(ng-app)视图(ng-view)中。</p>			<h3>Module - ngRoute</h3>			<p>AngularJS的路由机制是靠一个单独的模块 -- ngRoute提供的，通过hash和history两种方式实现了路由，可以检测浏览器是否支持history来灵活调用相应的方式。ngRoute包含以下内容：	</p>			<ul>					<li>服务$routeProvider用来定义一个路由表，即地址栏与视图模板的映射</li>					<li>服务$routeParams保存了地址栏中的参数，例如{id : 1, name : 'tom'}</li>					<li>服务$route完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的controller</li>					<li>指令ngView用来在主视图中指定加载子视图的区域</li>			</ul>			<p>AngularJS的前端路由，虽然URL输入不一样，页面展示不一样，其实完成的单页(ng-app)视图(ng-view)的局部刷新。</p>			<p>PS：以上内容再加上$location服务，我们就可以实现一个单页面应用了。</p></section><section  ng-show="currentShow == '1'">		<h3>Step1-- 引入文件和依赖</h3>		<p>ngRoute模块包含在一个单独的文件中，所以第一步需要在页面上引入这个文件，如下：</p>		<pre>		&lt;script src="http://code.angularjs.org/1.2.5/angular.min.js"&gt;&lt;/script&gt;		&lt;script src="http://code.angularjs.org/1.2.5/angular-route.min.js"&gt;&lt;/script&gt;</pre>						<p>光引入还不够，我们还需在模块声明中注入对<span style="color:red;">ngRoute</span>的依赖，如下：</p>				<pre>		var app = angular.module('MyApp', ['ngRoute']);</pre>				<p>完成了这些，我们就可以在模板或是controller中使用上面的服务和指令了。</p>				<h3>Step2 -- 定义路由表</h3>				<p>		$routeProvider提供了定义路由表的服务，它有两个核心方法：</p>				<h4>when(path,route)</h4>		<p><strong>when(path,route)方法接收两个参数</strong></p>		<p>path是一个string类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。</p>		<div style="background:white;margin:20px;line-height:24px;"> 		如果需要匹配参数，可以在path中使用冒号加名称的方式，如：path为/show/:name，<br/>		如果地址栏是/show/tom，那么参数name和所对应的值tom便会被保存在$routeParams中，像这样：{name : tom}。<br/>		我们也可以用*进行模糊匹配，如：/show*/:name将匹配/showInfo/tom。		</div>						<p>route参数是一个object，用来指定当path匹配后所需的一系列配置项，包括以下内容：</p>		<div style="background:white;margin:20px;line-height:24px;"> 				<ul>						<li>controller //function或string类型。在当前模板上执行的controller函数，生成新的scope</li>						<li>controllerAs //string类型，为controller指定别名</li>						<li>template //string或function类型，视图所用的模板，这部分内容将被ngView引用</li>						<li>templateUrl //string或function类型，当视图模板为单独的html文件或是使用了&lt;script type="text/ng-template"&gt;定义模板时使用</li>						<li>resolve //指定当前controller所依赖的其他模块</li>						<li>redirectTo //重定向的地址</li>				</ul>		</div> 				<h4>otherwise(params)</h4>		<p>otherwise(params)方法对应路径匹配不到时的情况，这时候我们可以配置一个redirectTo参数，让它重定向到404页面或者是首页。</p>		<br/>		<h4>code:</h4>		<pre>		app.config(['$routeProvider',function ($routeProvider) {			$routeProvider				.when('/', {						templateUrl : 'home.html',						controller  : 'homeCtrl'				})				.when('/router/:id', {						templateUrl : 'router.html',						controller  : 'routerCtrl'				}).otherwise({						redirectTo: '404.html'				});		}]);		</pre>		<pre>		app.controller("routerCtrl", ['$scope', '$routeParams',function($scope, $routeParams) {				$scope.currentId = $routeParams.id;		}]);		</pre>				<h3>Step3 -- 指定加载子视图区域</h3>		<p>我们的单页面程序都是局部刷新的，那这个“局部”是哪里呢，这就轮到ngView出马了，只需在模板中简单的使用此指令，在哪里用，哪里就是“局部”。例如：</p>		<pre> &lt;div ng-view&gt;&lt;/div&gt;  Or  &lt;ng-view&gt;&lt;/ng-view&gt;	</pre>		<p>我们的子视图将会在此处被引入进来。</p>				<br/><br/><br/></section><section  ng-show="currentShow == '2'"><h3>route的resolve参数</h3><p><strong>resolve - {Object. &lt;key, value&gt;} : </strong> resolve参数定义了一个可选的要注入到controller中的依赖的map。</p><p>如果这些依赖中有promises对象，那么router会在控制器实例化之前等待他们都得到解决或其中一个被拒绝。如果所有的promises都成功返回了resolved的结果，那么这些结果将会被注入到controller中，同时触发$routeChangeSuccess事件。任何一个promise被rejecte都会触发$routeChangeError事件。</p><p>	<strong>map Object 的定义方式如下：</strong>	<ul>			<li> <strong>key –  { string } : </strong>被注入到controller中的依赖的名字。</li>			<li> <strong>value - { string | function } : </strong>					<ul>						<li>如果这个值是string，那么它必须是一个service的别名(alias)。</li>						<li>如果这个值是function, 那么它将会被注入，它的返回值会被当着是依赖对象。 								<ul>										<li>如果这个方法的返回值是一个promise对象，那么只有它返回resolved结果后，返回值才会被注入到controller中。 </li>										<li  ng-class=" {'emPactive': isEm}">需要注意的是，在它的resolve functions中ngRoute.$routeParams仍然指向前一个route，想访问新的 route parameters，就需要使用$route.current.params。 </li>								</ul>						</li>					</ul>			</li>	</ul></p><p><strong>场景 -- 预加载</strong></p>	<p>之前做应用的时候都会在首页就把全站的js预先加载进来。。。怎么实现按需加载，在德问上看到一个方案用AngularJS构建单页应用,怎样根据需求加载JS文件？</p><p>首先在$routeProvider里面加resolve属性：</p><pre>$routeProvider.when('/phones', {		templateUrl: 'partials/phone-list.html', 		controller: PhoneListCtrl, 		resolve: PhoneListCtrl.resolve})</pre><p>然后</p><pre>function PhoneListCtrl($scope) {  //...}PhoneListCtrl.resolve = {  delay: function($q) {    var delay = $q.defer(),    load = function(){        $.getScript('/js/xxxxx.js',function(){        delay.resolve();        });    };    load();    return delay.promise;  }}</pre><br/><br/><br/></section>