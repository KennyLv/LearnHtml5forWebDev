<h1>AngularJS  的 -- <span style="color:red;">运行原理</span> </h1><!--http://angularjs.cn/A00qhttp://www.sitepoint.com/understanding-angulars-apply-digest/http://jasonmore.net/angular-js-directives-difference-controller-link/http://segmentfault.com/q/1010000000664866http://www.ifeenan.com/angularjs/2014-09-04-%5B%E8%AF%91%5DNG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/http://www.html-js.com/article/2000http://www.adobe.com/cn/devnet/html5/articles/angularjs-directives-and-the-computer-science-of-javascript.html--><section  ng-show="currentShow == '0'"><h3>How AngularJS Starts up in your browser?</h3><pre>	&lt;html ng-app&gt;	&lt;body&gt;			&lt;div ng-init="name='Kitty'"&gt;Hello {{name}}!&lt;/div&gt;			&lt;script src="angular-1.0.1.js"&gt;&lt;/script&gt;	&lt;/body&gt;	&lt;/html&gt;</pre><p>这个过程可以简单描述如下：</p><ol>		<li>浏览器加载HTML，将HTML标签转换为DOM对象；</li>		<li>浏览器加载angular.js的脚本；</li>		<li>AngularJs等待DOMContentLoaded事件；</li>		<li>AngularJs寻找ng-app这个用于指定应用边界范围的directive；</li>		<li>AngularJs遍历指定范围内的DOM，找到所有的directive。</li>		<li>模板引擎$compile服务用作“编译”DOM中的directives，并将其与对应的Model数据（$rootScope）连接。</li>		<li>ng-init 这个directive在对应的scope中创建name属性并对其赋予”Kitty”值；</li>		<li>AngularJs的控制器将“{{name}}”的值通过更新到view上，最终显示”Hello Kitty!”。</li></ol><!--<img src="./img/startup.png"/><ol>		<li>浏览器加载HTML，将HTML标签转换为DOM对象；</li>		<li>浏览器加载angular.js的脚本；</li>		<li>Angular等待DOMContentLoaded事件；</li>		<li>Angular寻找ng-app这个用于指定应用边界范围的directive；</li>		<li>如果ng-app有指定module（也许是ng-app=”SomeApp”），将被用作配置$injector；</li>		<li> $injector用于创建$compile服务（service）以及$rootScope；</li>		<li>$compile服务用作“编译”（有点像遍历，然后做一点神秘的事情）DOM，并将其与对应的$rootScope连接。</li>		<li>ng-init 这个directive在对应的scope中创建name属性并对其赋予”Kitty”值；</li>		<li>将“{{name}}”的值插入(interpolates)到表达式中，最终显示”Hello Kitty!”。</li></ol>--><br/><br/><br/></section>	<section  ng-show="currentShow == '1'"><!--http://www.cnblogs.com/lcllao/archive/2012/09/09/2677190.html-->			<h3>AngularJs页面编译的三个阶段</h3>			<ol>			<li><strong>指令查找阶段：</strong>AngularJs编译器遍历DOM查找HTML中的directives，并会按照优先级排序加入一个指令列表中。</li>			<li><strong>指令编译阶段：</strong>directives加入列表时，他们的compile方法会被调用，directives的$compile()函数能修改DOM结构，并且负责生成一个链接函数（link function）。</li>			<li><strong>指令绑定阶段：</strong>$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。			通过轮流调用上一步所说的每一个指令的链接函数来将View与Model中的作用域（scope）链接起来（这会让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听）。</li>			</ol>			<!-- <img src="./img/view.png" style="height:200px;margin-left:200px;"/>-->				<h3>典型的directive示例</h3><pre>angular.module("TestApp",[]).directive('directiveName', function () {		 return  {			priority: 0,			templateUrl: 'directive.html',			restrict: 'A',			scope: {					...			},			compile: function(tElement, tAttrs, transclude) {				//编译函数在directive中是比较少见的，因为大多数directive只关心与指定的DOM元素工作，				//而不是改变DOM元素的模版（DOM自身以及内部的结构）。				//为了优化性能，一些可以被directive实例共享的操作，可以移动到compile函数中。				//需要compile function的directive，一般是那种需要转换DOM模版的（如ngRepeat），				//或者是需要异步加载内容的（如ngView）。				return {					pre: function(scope, iElement, iAttrs, controller) { 						//Pre-link function，在子元素linked之前执行					},					post: function(scope, iElement, iAttrs, controller) { 						//Post-link function，在子元素linked之后执行。					}				}			},			link : function(scope,elem,attrs,ctrl,transclude){				//link function允许directive在指定的拷贝后的DOM元素实例上注册监听器，也可以将scope中特定内容复制到DOM中。				//link function会在模版克隆操作完毕之后执行。			}		}; });</pre>	<!--	九、Compile functionfunction compile ( tElement, tAttrs, transclude) { … }　　compile function用于处理DOM模版的转换。由于大多数directive都不需要转换模版，所以compile不会经常被使用到。需要compile function的directive，一般是那种需要转换DOM模版的（如ngRepeat），或者是需要异步加载内容的（如ngView）。compile function拥有一下的参数：							tElement - 模版元素 – 使用当前directive的元素。仅仅在当前元素或者当前元素子元素下做模版转换是安全的。							tAttrs - 模版属性 - 标准化的属性，在当前元素声明的，可以在各个directive之间共享。详情请看Attributes章节							transclude – 一个转换用的linking function:  function(scope,cloneLinking).　　注意：如果template被克隆过，那么template实例和link实例不能是同一个object。为此，在compile function中做任何除了DOM转换以外的事情，是不安全的，这将应用到所有克隆中。特别是，DOM事件监听器的注册的操作，应该在linking function中进行，而不是compile function。compile function 可以有一个返回值，类型可以是function或者object。返回function – 通常在不需要compile function（为空）时使用，等同于通过link(directive定义模版的属性)注册linking function。返回包含pre、post属性的object - 允许我们控制在linking phase期间何时调用linking function。详情请看下面关于pre-linking、post-linking function的章节。 十、Linking functionfunction link( scope, iElement, iAttrs, controller) { … }　　link function负责注册DOM事件监听器，也可以进行DOM的更新操作。link function会在模版克隆操作完毕之后执行。这里存放着directive大多数的逻辑。scope - Scope - 被directive用于注册watches(http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch)。iElement - 元素实例 - directive使用的元素。只有在postLink function里面对子元素进行操作，才是安全的。因为子元素已经被link（与model连接吗？！）。iAttrs - 属性实例 - 标准的当前元素的属性列表。在所有directive的linking function之间分享的。controller - controller实例 - 如果在当前元素的directive中，有其中一个定义了controller，那么可以在这里获取到该controller的实例。这个controller是在所有directive之间共享的，允许各个directive将controller当作一个它们之间沟通频道。 Pre-link function　　在子元素linked之前执行。在这里做DOM转换是不安全的，因为compiler的linking function在link时可能会定位不到正确的元素。Post-link function　　在子元素linked之后执行。在这里执行DOM转换是安全的。	-->			<h3>双向数据绑定的实例分析</h3>		<pre>		&lt;html ng-app&gt;		&lt;body&gt;			&lt;input ng-model="name" class="ng-cloak"/&gt;			&lt;p&gt;Hello {{name}}!&lt;/p&gt;			&lt;script src="../angular-1.0.1.js" type="text/javascript"&gt;&lt;/script&gt;		&lt;/body&gt;		&lt;/html&gt;		</pre>		<p>1. 编译阶段(compilation phase)：</p>			<ul>					<li>ng-model指令在&lt;input&gt;中绑定keydown事件监听器。</li>					<li>在模版linking的阶段， {{name}}（表达式）在scope中对name对象设置监听（$watch表达式）以便在name发生改变时有所响应。</li>					</ul>			<p>2. 执行阶段(runtime phase)：</p>			<ul>					<li>在inut控件中按下”X”按钮，让浏览器触发一个keydown事件；</li>					<li> input directive捕捉到文本框值的改变，然后调用$apply(“name = ‘X’;”)，在angular的执行上下文中更新应用的model。</li>					<li>开始$digest循环，检测name的观察者。</li>					<li> $watch list检测到name的值被改变了，然后再次解析{{name}}表达式，然后更新DOM。</li>					<li>Angulart退出(angular) 执行上下文，再依次退出keydown事件以及javascript 执行上下文；</li>					<li> 浏览器重绘视图，更新字符。</li>			</ul>					<br/><br/><br/>						<!--HTML“编译”的三个步骤：1. 首先，通过浏览器的标准API，将HTML转换为DOM对象。这是很重要的一步。因为模版必须是可解析（符合规范）的HTML。这里可以跟大多数的模版系统做对比，它们一般是基于字符串的，而不是基于DOM元素的。2. 对DOM的编译（compilation）是通过调用$comple()方法完成的。这个方法遍历DOM，对directive进行匹配。如果匹配成功，那么它将与对应的DOM一起，加入到directive列表中。只要所有与指定DOM关联的directive被识别出来，他们将按照优先级排序，并按照这个顺序执行他们的compile() 函数。directive的编译函数（compile function），拥有一个修改DOM结构的机会，并负责产生link() function的解析。$compile()方法返回一个组合的linking function，是所有directive自身的compile function返回的linking function的集合。3. 通过上一步返回的linking function，将模版与scope连接起来。这反过来会调用directive自身的linking function，允许它们在元素上注册一些监听器（listener），以及与scope一起建立一些watches。这样得出的结果，是在scope与DOM之间的一个双向、即时的绑定。scope发生改变时，DOM会得到对应的响应。Compiler作为Angular的一个服务（Service），负责遍历DOM结构，寻找属性。编译过程分成两个阶段：1. 编译（Compile）：遍历DOM节点树，收集所有directives。返回结果是一个链接函数（linking function）。2. 链接（Link）：将directives绑定到一个作用域（scope）中，创建一个实况视图（live view）。在scope中的任何改变，将会在视图中得到体现（更新视图）；任何用户对模版的活动（改变），将会体现在scope model中（双向绑定）。这使得scope model能够反映正确的值。一些directives，诸如ng-repeat，会为每一个在集合（collection）中的元素复制一次特定的元素（组合）。编译和链接两个阶段，使性能得以提升。因为克隆出来的模版(template)只需要编译一次，然后为每一个集合中的元素进行一次链接（类似模版缓存）。-->			</section><section  ng-show="currentShow == '2'"><!-- http://www.ruanyifeng.com/blog/2013/10/event_loop.htmlhttp://wiki.nodejs.tw/nodejs_from_scratch/javascript-yunodejs/2-1-event-loophttp://book.51cto.com/art/200804/70915.htm C.1.1  --><h3>AngularJs 对javascript事件的监听</h3><p><strong>什么是Event Loop</strong></p><p>浏览器的所有的时间处理函数，以及timer执行的函数，会排在一个queue结构中，利用一个无限的循环，不断从queue中取出函数来执行，这个就是event-loop	。</p><ul>	<li>1. 浏览器event-loop等待事件到来。事件来自于用户交互（DOM events）、timer事件（setTimeout）、network事件（服务端响应，XHR之类）；</li>	<li>2. 事件回调函数开始执行。这里进入javascript上下文（context）。这回调函数可以修改DOM结构。</li>	<li>3. 当回调函数执行完毕后，浏览器退出javascript context，根据DOM的改变来重绘视图。</li></ul><p><strong>AngularJs的事件处理</strong></p><p>Angular通过创建自己的事件处理循环（event processing loop），修改了一般的javascript流（flow）。这将Javascript分割成传统的和Angular的执行上下文（execution context）。只要是在Angular execution context 里面执行的操作，都拥有angular data-binding、异常处理（exception handling）、属性监视（property watching）等能力。<br/>我们可以通过在javascript使用$apply()，进入Angular execution context。但要记住一点，在大多数（angular的）地方（如controllers、services），处理事件的directive会为你调用$apply。手动调用$apply的场景，一般是当你实现自定义事件处理函数，或者处理第三方库的回调的时候。</p><ol>		<li>通过调用scope.$apply(stimulusFn)进入angular execution context。stimulusFn就是我们想在angular execution context中执行的函数（含scope作为参数）或者angular合法的表达式。</li>		<li>Angular执行stimulusFn，这通常会改变应用的状态（application state）。</li>		<li>Angular进入$digest loop。这个loop由一个处理$evalAsync queue 和处理$watch list两个更小的循环组成。$digest loop会在model稳定之前保持迭代。</li>		<li>$evalAsync queue被用作安排必须跳出当前堆栈帧。</li>		<li>$watch list是有可能在最近一次迭代中被修改的表达式的集合。如果(model)发生了改变，那么$watch 函数会被调用，从而达到对特定的DOM重新赋值的目标。</li>		<li> 一旦Angular $digest loop 完成了（之前3提到的情况），离开angular和javascript的context后，浏览器紧跟着就会去重绘DOM，以响应变化。</li></ol><p>这图表和后面的例子，描述了angular如何通过浏览器event-loop来进入自己的上下文：</p><img src="./img/eventloop.png"/><br/><br/></section>	<section  ng-show="currentShow == '3'">					<!--Factory method工厂函数   与 $Injectorhttp://angularjs.cn/A00rhttp://www.cnblogs.com/lcllao/archive/2012/09/07/2671227.html--><!--<img src="./img/Module & Injector.png"/>Injector是一个服务定位器。每一个Angular应用，都会有一个单独的injector。Injector提供一个通过名称查找对象实例的途径。Injector会在内部cache中保持所有对象实例，所以重复调用相同的名称时，返回的都是同一个对象实例。如果对象不存在，那么它会请求实例工厂（instance factory）去创建一个新实例。Module是一个配置injector的实例工厂的方法，被称为”provider”。但是injector的真正牛X的地方在于它可以用于调用方法和”instantiate” type。这个美妙的特性是允许method和types请求他们所依赖的资源，而不是寻找他们。注意，我们唯一需要写的，就是我们的function，在function的arguments中列出方法依赖的资源即可！当angular调用function时，他会使用”call”方法，自动填充function agruments。留意下面的例子中是如何在constructor中列出依赖的。当ng-controller实例化controller时，将自动提供所依赖的资源。没有必要去创建、寻找、创建injector引用来加载依赖资源。工厂函数是用来创建指令的。它只会被调用一次：就是当编译器第一次匹配到相应指令的时候。你可以在其中进行任何初始化的工作。调用它时使用的是 $injector.invoke ， 所以它遵循所有注入器的规则。-->		<!--用参数数组的方式添加了$scope的引用，在AngularJs中我们称为“依赖注入”，而AngularJs实现依赖注入的方式也是通过$Injector这个服务实现的。1，所有的AngularJs服务都是实现为单例模式，并注册在依赖注入系统中。<br/>2，当AngularJs启动时，Controller开始启动构造的时候，通过参数指出依赖。<br/>3，AngularJS的依赖注入系统帮你查找左右依赖，负责实例化，并且按照工场函数要求的样子传递依赖。<br/>-->			</section>	