<h1>AngularJS  的路由机制 -- <span style="color:red;">历史记录 $Location</span> </h1><!--使用$locationhttp://angularjs.cn/A00MAngularJS去掉的URL里的#号http://blog.fens.me/angularjs-url/AngularJS中locationchange、routechange事件 http://blog.csdn.net/spy19881201/article/details/17096675全面讲解http://www.cnblogs.com/lcllao/archive/2012/09/30/2709187.html--><section  ng-show="currentShow == '0'">		<p><strong>假设有这样一场景：在用户切换到另外一个route时，需要检查当前表单（内容）是否已保存，这个能不能在AngularJS中实现呢？</strong></p>		<h3>$route服务</h3>		<div style="background:white;margin:20px;line-height:24px;"> 			$route is used for deep-linking URLs to controllers and views (HTML partials). It watches $location.url() and tries to map the path to an existing route definition.  		</div>		<p>$route服务原来只是监视$location服务中某个数据变化的...</p>		<p><strong>顺藤摸瓜，来看看$location服务...</strong></p>				<h3>$location服务</h3>		<p>$location服务解析地址栏中的URL（基于window.location），让你在应用代码中能获取到。改变地址栏中的URL会反应$location服务中，反之亦然。你可以利用它：</p>		<p><strong>1，暴露当前地址栏的URL，这样你就能</strong></p>		<ul>			<li>获取并监听URL。</li>			<li>改变URL。</li>		</ul>		<p><strong>2，当出现以下情况时同步URL</strong></p>		<ul>			<li>改变地址栏。</li>			<li>点击了后退按钮（或者点击了历史链接）。</li>			<li>点击了一个链接。</li>		</ul>		<p><strong>3，一系列方法来获取URL对象的具体内容用（protocol, host, port, path, search, hash）</strong></p>				</section><section  ng-show="currentShow == '1'">		<p><strong>回到刚才的场景</strong></p>		<p>我们首先来分析下，场景中有那些事件流。</p>		<ol>			<li>用户编辑了表单</li>			<li>用户准备点击另外一个route url，触发提示‘是否要保存’</li>			<li>点击‘是’，route切换事件停止；点击‘否’，route切换事件继续</li>		</ol>		<p>主要流程就这些其实很简单。那么我们能否利用$route服务或者$location服务，根据url的变化来实现这个过程呢？</p>		<p>翻看API，找到了两个方法：</p>		<h3>$location - $locationChangeStart vs $route - $routeChangeStart</h3>		<div style="background:white;margin:20px;line-height:24px;"> 		<strong>$locationChangeStart - Broadcasted before a URL will change.</strong> <br/>		<span style="color:red;">This change can be prevented by calling preventDefault method of the event. </span><br/>		See $rootScope.Scope for more details about event object. Upon successful change $locationChangeSuccess is fired.		</div>				<div style="background:white;margin:20px;line-height:24px;"> 		<strong>$routeChangeStart - Broadcasted before a route change.</strong> At this point the route services starts resolving all of the dependencies needed for the route change to occur. Typically this involves fetching the view template as well as any dependencies defined in resolve route property. Once all of the dependencies are resolved $routeChangeSuccess is fired.		</div>				<p>route是监控location.url的，所以事件的触发应该是先location后route事件，验证一下:</p><pre>app.run(['$rootScope', '$window', '$location', '$log', function ($rootScope, $window, $location, $log) {  		var locationChangeStartOff = $rootScope.$on('$locationChangeStart', locationChangeStart);  		var locationChangeSuccessOff = $rootScope.$on('$locationChangeSuccess', locationChangeSuccess);  		var routeChangeStartOff = $rootScope.$on('$routeChangeStart', routeChangeStart);  		var routeChangeSuccessOff = $rootScope.$on('$routeChangeSuccess', routeChangeSuccess);  		function locationChangeStart(event) {  			$log.log('locationChangeStart');  		}		function locationChangeSuccess(event) {  			$log.log('locationChangeSuccess');  		}  		function routeChangeStart(event) {  			$log.log('routeChangeStart');  		}  		function routeChangeSuccess(event) {  			$log.log('routeChangeSuccess');  		}  }]);  </pre><p>我们只需要处理 locationChangeStart，我们利用location改变事件来实现了在提交Location之前做了定制化：</p><pre>function locationChangeStart(event, newUrl) {  		var ret = $window.confirm('Are you sure to give it up? ');  		if (ret) {  				<strong style="color:red;">locationChangeStartOff(); </strong> //Stop listening for location changes or you can do others  				$location.path(newUrl);  				return;  		}  		<strong style="color:red;">event.preventDefault();  </strong>		return;  }  </pre><p>而route事件是在URL改变之后发生，因此我们可以利用route事件做一些类似“loading...”的效果。</p><br/><br/><br/><br/></section><section  ng-show="currentShow == '2'">	<p>$location服务除了为URL只读部分(absUrl, protocol, host, port)提供读方法，还为可读写部分（url, path, search, hash）也提供了读写方法：</p>		<h3>URL更新</h3>		<p><strong>1，URL getter and setter</strong></p>	<pre>	// get the current path	$location.path();	// change the path	$location.path('/newValue')	//所有的写方法返回同一个$location对象来支持链式风格。	//比如，要在一条语句中改变URL的多个部分：	$location.path('/newValue').search({key: value});	</pre>	<p>	$location服务有一个特殊的replace方法可以用来告诉$lacation服务下一次自动和浏览器同步，上一条浏览记录应该被替换而不是创建一个新的。	这在重定向的时候很好用。不这样的话容易使后退按钮失效（点后退时会又触发重定向）。	要改变URL而不添加新的历史记录，你可以这样做：	</p>	<pre>	$location.path('/someNewPath');	$location.replace();	// or you can chain these as: $location.path('/someNewPath').replace();	</pre>	<p><strong>2，URL setter & window.location</strong></p>	<p>	<strong>写方法并不会马上更新window.location，而是在作用域的$digest阶段将多个$location操作合并成一个对windiow.location对象的commit操作。</strong>	因为多个操作会后对浏览器来说都会只是一个，所以只要调用一次replace()方法就能实现浏览器记录的替换操作。一旦浏览器更新了，$location服务就会将replace方法的标志重置，以后的改变就会创建新的历史记录，直到再次调用replace方法。	</p>	<p><strong>3，写方法和字符编码</strong></p>	<p>你可以给$location服务传递特殊字符，它会根据RFC 3986规则来编码。当你调用写方法时：</p>	<ul>			<li>所有传递给写方法（如path(), search(), hash()）的值都会被编码。</li>			<li>读方法（path(), search(), hash()不带参数的调用）返回解码后的值。</li>			<li>当你调用absUrl()时，会返回各部分经过了编码的完整url。</li>			<li>当你调用url()时，返回的值是path, search 和hash，形式是/path?search=a&b=c#hash。</li>	</ul><br/><br/><br/><br/></section><section  ng-show="currentShow == '3'"><p>$location服务有两种用来控制地址栏URL格式的配置：Hashbang模式（默认）和HTML5模式（使用HTML5历史API）。应用会使用两种模式中相同的API，并且$location服务会使用需要的URL片段和浏览器API来帮助改变URL或者进行历史管理。</p><img src="./img/hashbang_vs_regular_url.jpg" /><h3>Hashbang模式(默认)</h3>		<p>使用这个模式的话，$location会在所有浏览器中使用Hashbang URLs。<strong>如果要支持网络爬虫，</strong>你需要添加特别的meta标记在你的文档的头部才能支持对你的AJAX应用的索引。</p>		<pre>&lt;meta name="fragment" content="!" /&gt;</pre>		<p>这能让网络爬虫请求带有_escaped_fragment_形式的参数链接，这样你就能识别爬虫并且返回一个HTML的快照了。</p>		<p>关于网络爬虫，参考		<a href="http://code.google.com/web/ajaxcrawling/index.html ">"making Ajax applications crawlable"</a>或者		<a href="https://developers.google.com/webmasters/ajax-crawling/docs/specification?csw=1">这里</a>。		</p><h3>HTML5模式</h3>		<p>在HTML5模式中，$location服务的读写器和浏览器的URL地址通过HTML5历史API交互，这使你能用regular URL path并且搜索各组成部分，和hashbang是等效的。 </p>		<pre>$locationProvider.html5Mode(true).hashPrefix('!');</pre>		<p><strong>浏览器支持</strong></p>		<p>			如果浏览器不支持HTML5 历史API， $location服务会自动回退成使用hashbang URLs：			<ul>				<li>在低级浏览器中使用了regular URL -> 重定向成hashbang URL</li>				<li>在现代浏览器中打开了一个hashbang URL -> 重写成regular URL</li>			</ul>		</p>		<p><strong>History API</strong></p>		<p>				使用这种模式，<strong>应用历史API时</strong>，在不同的浏览器中你需要使用不同的链接，但是你需要做的仅仅是指定好regular URL形式的链接，				如： <span style="color:white;">&lt;a href="/some?foo=bar"&gt;link&lt;/a&gt;</span>		</p>		<p>当用户点击这个链接时			<ul>				<li>在低级浏览器中，URL转换成 <span style="color:white;">/index.html#!/some?foo=bar</span></li>				<li>在现代浏览器中转换成 <span style="color:white;">/some?foo=bar</span></li>			</ul>		</p>		<p>但如果是下面的这中形式，连接不会被重写。取而代之的是，浏览器会根据链接重新加载页面。			<ul>				<li>包含target的链接，  <span style="color:white;">&lt;a href="/ext/link?a=b" target="_self"&gt;link&lt;/a&gt;</span></li>				<li>指向其他域的绝对路径， <span style="color:white;">&lt;a href="http://angularjs.org/"&gt;link&lt;/a&gt;</span></li>				<li>当base被定义时，使用'/'开头指向一个不同的base路径， <span style="color:white;">&lt;a href="/not-my-base/link"&gt;link&lt;/a&gt;</span></li>			</ul>		</p>		<p><strong>服务器端的URL重写</strong></p>		<p>使用这种模式，<strong>需要开启服务器端的URL重写功能</strong>，基本上你需要重写所有指向你应用的链接(如index.html)。</p>				<p><strong>资源的相对路径</strong></p>		<p>				使用这种模式，<strong>记住要检查所有的相对连接、图片、脚本</strong>等。你必须指定你主页面的base url(&lt;base href="/my-base"&gt;)，				或者你使用绝对路径也行，因为相对路径会结合文档的初始绝对路径转换成绝对路径。文档初始路径通常和应用的根路径不一样。				我们强烈推荐应用使用文档根节点开始的历史API，因为它能处理好所有相对路径的问题。		</p><br/><br/><br/><br/></section>				<section  ng-show="currentShow == '4'"><h3>页面的重新加载</h3><p>$location服务职能让你改变URL，不能让你重新加载页面。但你需要重新加载页面或者跳转到另外的页面时，请使用更低级别的API -- $window.location.href。</p><p><strong>方式一：</strong>&lt;a href="..." <span style="color:red;">target="_self"</span>&gt;link&lt;/a&gt; </p><p><strong>方式二：</strong>在a标签中使用自定义指令实现强制刷新：&lt;a <span style="color:red;">di-href</span>="/controllerTest"&gt;controllerTest&lt;/a&gt;<pre>app.directive('diHref', ['$location', '$route', function($location, $route) {	  return function(scope, element, attrs) {			  scope.$watch('diHref', function() {					  if(attrs.diHref) {							  element.attr('href', attrs.diHref);							  element.bind('click', function(event) {									  scope.$apply(function(){											  if($location.path() == attrs.diHref){														$route.reload();											  }										 });							 });					 }			 });	 }}]);</pre></p><h3>不同浏览器中的链接</h3><p>因为HTML模式的重写能力，你的用户能在低级浏览器中使用regualr url，在现代浏览器中使用hashbang url。</p><!--<h3>在作用域生命周期外使用$location</h3><p>$location知道应用作用域的声明周期。但URL改变时，它会更新$location，并且调用$apply，这样所有的监听它的程序都会收到。当你在$digest阶段改变URL，那么没什么问题。$location会将改变传递给浏览器，并且通知所有的监听者。但是如应用之外使用$location的话（比如，在DOM事件中或者测试中），你就要手动调用它$apply来传递改变。</p>--><h3>$location.path() 和 "!" "/" 前缀</h3><p>一个路径应该总是以斜杠开始，$location.path()写方法会在没有前缀/时自动添加。注意，hashbang模式中的"!"前缀实际上不是$location.path()的一部分，它其实是hashPrefix。</p><br/><br/><br/><br/></section>