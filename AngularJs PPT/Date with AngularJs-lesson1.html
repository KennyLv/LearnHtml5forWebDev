<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>Javascript Framework & AngularJs</title>
		<meta name="author" content="Kenny">
		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<link type="text/css" rel="stylesheet" href="css/reveal.css">
		<link type="text/css" rel="stylesheet" href="css/theme/default.css" id="theme">

		<link type="text/css" rel="stylesheet" href="css/style.css">

		<link type="text/css" rel="stylesheet" href="./angularjs/style.css">

		<script type="text/javascript" src="./js/shBrushCore.js"></script>
		<script type="text/javascript" src="./js/shBrushJScript.js"></script>
		<link type="text/css" rel="stylesheet" href="./css/shBrushCoreDefault.css"/>
		<script type="text/javascript">
			SyntaxHighlighter.all();
		</script>
	</head>

	<body style="-webkit-transition: -webkit-transform 0.8s ease; transition: -webkit-transform 0.8s ease;">
		<div class="reveal zoom">
			<div class="slides" ng-app="angularDemoModule" ng-controller="myTipsCtr" >

				<section class="cover present" style="display: block;">
					<h1>Date with AngularJs</h1>
					<h3>@ Kenny</h3>
				</section>

				<section class="future" style="display: block;">
					<h2>Agenda - By this ...<span style="color:red;font-size:60px;"> #% $%@ #&%^ &#$</span>... way ...</h2>
					<ul id="main_menu">
						<li>
							Who is AngularJs?
						</li>
						<li>
							First look at AngularJs.
						</li>
						<li>
							Get closer to AngularJs.
						</li>
						<li>
							Interested in AngularJs.
						</li>
						<li>
							Fall in LOVE with AngularJs.
						</li>
						<li>
							Fascinated with angularjs.
						</li>
						<li>
							Time to say YES?
						</li>
						<li>
							Enjoy your life and Looking forward to the future.
						</li>
					</ul>
				</section>

				<section class="future" style="display: none;"  id="s_who_is_ajs">
					<section>
						<h4>Who is AngularJs?</h4>
						<p>WEB的实时&动态化</p>
						<span>
								交互的需要，多页面 WEB 应用程序通过组装和拼接服务器上的数据来创造它们的HTML ，然后将完成的页面输送给浏览器。ASP.NET<br/>
								<br/>
						</span>
						<p>富客户端的兴起</p>
						<span>
								后来随着交互的发展，富客户端/单页面应用逐渐兴起，Web Services & XML的广泛使用，使得Flex / SilverLight都有过短暂辉煌，						因为Asp.net是事件驱动，这些框架都是为消息驱动而生的，但是也由于各自的局限性，逐渐式微。
						</span>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						<p>动态web应用</p>
						<span>
						
								异步操作提升用户体验
								那么，什么又是呢？与传统web系统相区别，web应用能为用户提供丰富的操作，能够随用户操作不断更新视图而不进行url跳转。
								
								但是数据交互和用户体验的要求越来越高，有一项古老的技术Ajax焕发新生，异步的数据交互是得对dom操作更加频繁，								这个时候交互工具jQuery对DOM便捷的操作，Ajax的完美支持和浏览器兼容方面的优化迅速抢了头条。<br/>
						</span>
						<div class="fragment">
							<img src="./img/logo_jQuery.jpg" style="padding-left:300px;" />
						</div>
						<div class="fragment">
								<p>jQuery的亮点：</p>
								<ol>
									<li>选择器支持CSS3的大量选择符，定位元素轻而易举，合理的编码可以使html与js, css分离开，便于维护。</li>
									<li>灵活便捷的Ajax请求和回调操作。</li>
									<li>事件绑定功能，内部封装了很多事件，方便统一添加事件，提高了复用性和可维护性。</li>
									<li>它也封装了很多常用的操作，例如节点的添加删除、常用的动画效果、逻辑判断比较等等。避免了直接使用dom api进行繁琐的操作。</li>
									<li>本身提供了可扩展的函数，可以自己编写插件与核心jQuery对象进行集成使用。只要你理解js面向对象编程，熟悉jQuery API，就能写出很多定制的插件，复用在各种地方。</li>
								</ol>
						</div>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						<p>前端的独立化</p>
						<span>
								与此同时，Restful & JSON等技术的兴起，以及前端标准的更新（其实都是浏览器厂商竞争惹得祸），都极大的推动了web前端的独立化。服务器传递模板和数据到浏览器然后在端组装, 服务器的角色变成了只提供模板的静态资源和提供模板所需要的数据。<br/>
								<br/>
						</span>
						<p>前端框架的发展</p>
						<span>
								大型web应用和交互需求催生前端框架的发展，前端框架大大丰富，Dojo 、Prototype 、Jquery 、mootools 、AngularJS、Prototype 、Ember、ExtJS 、Knockout、YUI ......
						</span>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						<p>前端的挑战</p>
						<span>
							内容型网页的响应式设计，混合式APP的发展对前端开发工作从表现层设计到代码结构上都提出了新的挑战：
							<br/>
							<ul>
									<li>从技术角度：浏览器兼容性、通用组件、W3C标准</li>
									<li>从管理角度：JS规范、CSS规范、DHtml/DOM规范</li>
									<li>从设计角度：交互与用户体验分析及创新</li>
							</ul>
							<br/>
							<br/>
							这些挑战中，JS规范与表现层的代码结构为甚，因为前端技术中最重要的一环 JavaScript 却缺少一个标准的模块化系统 ：<br/>
							-- 有些基础库会把所有模块打包成一个文件，如jQuery，<br/>
							-- 另一些大型库都有自己的模块系统，但代码不能通用 ，如 ExtJS, 几乎每个流行框架都有一套自己的 DOM wrapper...<br/>
						</span>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						 <p>"Hello World" by jquery-tmpl <span style="color:lightgreen;"> (https://github.com/BorisMoore/jquery-tmpl) </span>:</p>
						<pre class="brush:js;">
							// Defined a HTML view, and Compile the markup view as a named template
							var markup = "<li><b>Hello ${Name}</b></li>";
							$.template( "helloTemplate", markup );
							
							// Get data from server
							$.ajax({
									url: nameServiceUrl,
									dataType: "json",
									success: sayHelloToAll,
									... ...
							});

							// Within the callback, use .tmpl() to render the data.
							function sayHelloToAll( data ) {
									// Render the template with the "names" data and insert
									// the rendered HTML under the 'helloList' element
									$.tmpl( "helloTemplate", data ).appendTo( "#helloList" );
							}
						</pre>
						<my-Tips  class="fragment" tips="{contents : 'This is the View or ViewModel?',style:{direction:'l',position:{top:'150px',left:'430px'}}}"> </my-Tips>
						<my-Tips  class="fragment" tips="{contents : 'This is the Model?',style:{direction:'l',position:{top:'280px',left:'250px'}}}"> </my-Tips>
						<my-Tips  class="fragment" tips="{contents : 'This is the Controller?',style:{direction:'l',position:{top:'490px',left:'500px'}}}"> </my-Tips>
						<div class="fragment">
								<pre class="brush:js;">
								//the View may like this :
								&lt;ul id="helloList" style="... ..."&gt;&lt;ul&gt;
								</pre>
						</div>
						<div class="fragment">
								<pre class="brush:js;">
								//And the functions :
								$("#helloList").each(... ...);
								</pre>
						</div>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						<p>Question :</p>
						<span>如何像以前那样的保持声明事件的可读性，有利于分工？同时保持事件操作的便捷？保证模块化？让MVC不仅体现在代码结构上，更体现在专业分工上？</span>
						<div class="fragment">
							<span>也许我们能想到的HTML会长这个样子：</span>
							<pre class="brush:js;">
							
								&lt;ul sayHelloToAllNames&gt;
									...
								&lt;/ul&gt;
								
							</pre>
						</div>
						<my-Tips  class="fragment" tips="{contents : '<li>Hello #Names[x] goes here#</li>',style:{direction:'l',position:{top:'210px',left:'300px'}}}"> </my-Tips>
						<div class="fragment">
							<span>他能不能长这个样子？</span>
							<pre class="brush:js;">
							
								&lt;ul sayHello Names repeat_li&gt;
									&lt;li&gt;Hello #Names[index] goes here# !&lt;/li&gt;
								&lt;/ul&gt;
								
							</pre>
						</div>
						<div class="fragment">
							<span>或者再声明个事件：</span>
							<pre class="brush:js;">
							
								&lt;ul sayHello Names repeat_li&gt;
									&lt;li click="viewDetail"&gt;Hello #Names[index] goes here# !&lt;/li&gt;
								&lt;/ul&gt;
								
							</pre>
						</div>
						<div class="fragment">
							<span>更或者：</span>
							<pre class="brush:js;">
							
								&lt;Names&gt;
									&lt; repeat_name  click="viewDetail"&gt;Hello #Names[index] goes here# !&lt;/repeat_name&gt;
								&lt;/Names&gt;
								
							</pre>
						</div>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
						<span>
							看起来似乎我们只需要让浏览器能够识别新的标签和语法就OK啦。<br/>
							我们也许会联想到HTML的自定义属性和标签，可是静态的HTML能够为这些属性标签添加除了样式之外的其他行为么？<br/><br/>
						</span>
						<div class="fragment">
								<p>Let's have a try with ...</p>
								<pre  class="brush:js;">
									<!--
										<html ng-app>
											<head>
													<script src="http://code.angularjs.org/angular-1.0.1.min.js"></script>
											</head>
											<Names  class="tag_names" ng-controller="helloCtr" >
														<li ng-repeat="person in Names track by $index" ng-click="viewDetail(person)">Hello {{person.name}}!</li>
											</Names>
										</html>
									-->
								</pre>
						</div>
						<div class="fragment">
								<p>Sample Data : </p>
								<pre  class="brush:js;">
										[{"name": "Tom","description": "This is Tom ..."},{"name": "Emma","description": "Emma is short for AYAMAYA ..."}]
								</pre>
						</div>
						<div class="fragment">
								<p>How will this going?</p>
						</div>
						<div class="fragment">
								<Names  class="tag_names" ng-controller="helloCtr" >
											<!--<li ng-repeat="person in Names" ng-click="viewDetail(person)">Hello {{person.name}}!</li>-->
											<li ng-repeat="person in Names track by $index" ng-click="viewDetail($index)">Hello {{person.name}}!</li>
								</Names>
						</div>
						<my-Tips  class="fragment" tips="{contents : 'This is AngularJs  ( https://github.com/angular/angular.js )',style:{direction:'b',position:{top:'260px',left:'430px'}}}"> </my-Tips>
					</section>
					<section>
						<h4>Who is AngularJs?</h4>
							<p>So AngularJs is ... ...</p>
							<img src="./img/logo_AngularJs.jpg" style="padding-left:300px; width:200px;" /><br/>
							<em>
							AngularJS is an MV* framework that is ideal for use when building client-side single-page apps. 
							It is not a library, but a framework for building dynamic web pages. 
							It focuses on extending HTML and providing dynamic data binding, and it plays well with other frameworks (e.g., jQuery).<br/>
							</em>
							<span class="fragment">
								1，TA是一个框架，不是类库。<br/>
							</span>
							<span class="fragment">
								2，TA是Google推出Web应用开发框架，构建了一个MVC/MVVM的解决方案用于客户端动态web应用<!--，-->。<br/>
							</span>
							<span class="fragment">
								3，TA的核心是对HTML的扩展增强，并实现动态的数据绑定。<br/>
							</span>
							<span class="fragment">
								4，TA能够兼容其他的前端框架，如jQuery。<br/><br/>
							</span>
							<my-Tips  class="fragment" tips="{
									contents : '这一点很重要，因为它的官方也声明，AngularJs更适用于开发CRUD应用，即数据操作比较多的应用，而非其他DOM操作很频繁也很复杂的应用。',
									style:{direction:'l',position:{top:'440px',left:'480px'}}   }">
							</my-Tips>
							<span class="fragment">
									听上去不错哇，TA是怎么“extending HTML”的呢？又怎么实现“dynamic data binding”的呢？一幅很诱人的样子...<br/><br/>
							</span>
							<p  class="fragment">
									见个面吧。。。
							</p>
					</section>
					
				</section>

				<!--
				///////////////////////////////////////////// 基础 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part1</h1><h1>First look at AngularJs</h1>
					<!--
							(示例：baidu_map & 控件 & 天气插件 & qTips -- 想new几个new几个)
							估计是被忽悠了？ ---- 后面的代码很吓人啦！！
							好处 -- 不仅仅是MVC -- 工程化、开源（这个好处不用讲了，看看这个页面）
					-->
					<!--
							基础知识（对MVC的实现）
					-->
					<!--<span>
							何为HTML标签增强？<br/>
							后面会详细介绍：其实就是使你能够用标签完成一部分页面逻辑，具体方式就是通过自定义标签、自定义属性等，这些HTML原生没有的标签/属性。

							为了实现这些，AngularJS引入了一些非常棒的特性，包括模板机制、数据绑定、模块、指令、依赖注入、路由。<br/>
							通过数据与模板的绑定，能够让我们摆脱繁琐的DOM操作，而将注意力集中在业务逻辑上。<br/>

							它提供了一系列兼容性良好并且可扩展的服务，包括数据绑定、DOM操作、MVC设计模式和模块加载
							这些我将在以后的学习中一一研究。<br/><br/>
							AngularJS通过使用我们称为标识符(directives)的结构，
					</span>-->
				</section>

				<section class="future" style="display: none;">
						<section>
								<h4>About AngularJs</h4>
								<div>
									<p><!--Example 剖析-- Hello world!-->回到刚才的示例：</p>
									<pre  class="brush:js;">
										<!--
											<html ng-app>
												<head>
														<script src="http://code.angularjs.org/angular-1.0.1.min.js"></script>
												</head>
												... ...
												<Names  class="tag_names" ng-controller="helloCtr" >
															<li ng-repeat="person in Names track by $index" ng-click="viewDetail(person)">Hello {{person.name}}!</li>
												</Names>
												... ...
											</html>
										-->
										[{"name": "Tom","description": "This is Tom ..."},{"name": "Emma","description": "Emma is short for AYAMAYA ..."}]
									</pre>
								</div>
								<span class="fragment">
									很容易猜到，&lt;Names&gt;应该就是我们上面提到过的“HTML标签增强”。<br/>
								</span>
								<ul class="fragment">
									<li>那“ng-app, ng-controller, ng-repeat, ng-click”这些又是什么？</li>
									<li>那个双括号又是怎么把名字读取到的？</li>
									<li>只有这两段代码能把名称显示出来？</li>
								</ul><br/><br/>
								<span class="fragment" ><strong style="color:red;">Off course NOT. </strong> TA是有<a href="#/4/1">内涵</a>的 @_@</span>
						</section>
						<section>
								<h4>About AngularJs</h4>
									<p>完整示例：</p>
									<pre  class="brush:js;">
										<!--
											<html ng-app>
												<head>
														<script src="http://code.angularjs.org/angular-1.0.1.min.js"></script>
												</head>
												... ...
												<Names  class="tag_names" ng-controller="helloCtr" >
															<li ng-repeat="person in Names track by $index" ng-click="viewDetail($index)">Hello {{person.name}}!</li>
												</Names>
												... ...
												<script type="text/javascript">
													var app = angular.module("angularDemoModule", []);
													app.directive('Names', function() {
														  return {
																	restrict: 'EA',
																	template :'<ul></ul>',
														  }
													});
													app.controller('helloCtr', ['$scope', function($scope) {
															$scope.Names= [{ "name": "Tom",  "description": "This is Tom ..."},
																							{"name": "Emma","description": "Emma is short for AYAMAYA ..."}];
															$scope.viewDetail = function(i){
																alert(	$scope.Names[i].description );
															}
													}]);
												</script>
											</html>
										-->
									</pre>
									<my-Box class="fragment" boxstyle="{w:'800px',h:'420px',t:'360px',l:'20px'}"></my-Box>
						</section>
				</section>

				<section class="future" style="display: none;">
					<h4>ng-app <span style="font-size:32px;"> -- Set the satge for AngularJs</span></h4>
					<span>
							很多应用都有一个用于初始化和启动应用的main/ready方法。AngularJs 作为一个可以高度模块化的框架，不需要main方法，作为替代，TA使用了HTML语言常用的声明式方法，描述应用从哪里如何启动。<br/><br/>
					</span>
					<div class="fragment">
							<p>Module的声明方式</p>
							<pre   class="brush:js;">
									//在js中，我们调用angular对象的module方法来声明一个模块
									var app = angular.module("angularDemoModule", []); 
							</pre>
					</div>
					<div class="fragment">
							<p>Module 的引用</p>
							<span>
								在前面的<a href="./angularjs/demo/demo_code.html?img=1" target="_blank">示例</a>中，在&lt;html&gt;标签上多了一个"ng-app"，它的作用就是用来指定angular的作用域。
							</span>
							<pre   class="brush:js;">
									&lt;html ng-app&gt; //在<html>中添加ng-app属性意味着整个<html>都是AngularJS脚本作用域。
							</pre>
					</div>
					<div class="fragment">
							<span>
								既然是作用域，就应当具备灵活性，AngularJs支持在局部使用ng-app指令，如&lt;div ng-app&gt;。
							</span>
							<pre   class="brush:js;">
									&lt;div ng-app="angularDemoModule"&gt;...&lt;/div&gt;
							</pre>
					</div>
					<span class="fragment">ng-app在DOM中注入了AngularJs框架的各种特性，那么怎样才能通过TA利用DOM来展示自己呢？</span>
					<!-- TODO : factory，provider，service注入	-->
				</section>

				<section class="future" style="display: none;">
						<section>
								<h4>Directive <span style="font-size:32px;"> -- Let AngularJs show out</span></h4>
								<p>什么是Directive？</p>
								<span>
										Directive允许你以声明的方式扩展HTML的标签，Directive是教HTML玩一些新把戏的途径。
								</span>
								<div>
									<pre   class="brush:js;">
											var app = angular.module("testDemoModule", []).directive('myNames', function() {
												  return {
															restrict: 'EA',
															template :'<ul><li>This is a fixture data for test!</li><li>This is also a fixture data for test!</li></ul>',
												  }
											});
									</pre>
								</div>
								
								<div class="fragment">
										<span>
												在DOM编译期间，Directives匹配HTML并执行，这允许Directive注册行为或者转换DOM结构。
										</span>
										<a href="./angularjs/demo/demo_direct_basic.html" target="_blank">
												<pre   class="brush:js;">
														<!-- <my-Names  ng-app="testDemoModule"></my-Names> -->
												</pre>
										</a>
										<span>
												将Directive的名称放在属性、标签名、class名里面也可以触发该directive。<br/>
										</span>
										<pre   class="brush:js;">
												<!-- <div ng-app="testDemoModule" my-Names ></div> -->
										</pre>
										<span>
												Angular自带一组内置的directive，对于建立Web App有很大帮助。比如ngClick...<br/>
										</span>
								</div>
								
								<div class="fragment">
										<p>Directive的命名</p>
										<span>
											Directive有驼峰式（camel cased）的风格的命名，如ngBind（放在属性里貌似用不了~）。<br/>
											但directive也可以支蛇底式的命名（snake case），需要通过:（冒号）、-（减号）或_（下划线）连接。<br/>
											作为一个可选项，directive可以用“x-”或者“data-”作为前缀，以满足HTML验证需要。
										</span>
								</div>
						</section>
						<section>
							<h4>Directive <span style="font-size:32px;"> -- Let AngularJs show out</span></h4>
							<!--
							<span>
									Angular自带一组内置的directive，对于建立Web App有很大帮助。继续扩展的话，可以在HTML定义领域特定语言（domain specific language ,DSL)。<br/>
							</span>
							<div>
								简单的示例：
								在HTML中引用directives
										Directive有驼峰式（camel cased）的风格的命名，如ngBind（放在属性里貌似用不了~）。但directive也可以支蛇底式的命名（snake case），需要通过:（冒号）、-（减号）或_（下划线）连接。作为一个可选项，directive可以用“x-”或者“data-”作为前缀，以满足HTML验证需要。这里列出directive的合法命名：

										ng:bind
										ng-bind
										ng_bind
										x-ng-bind
										data-ng-bind
										Directive可以放置于元素名、属性、class、注释中。下面是引用myDir这个directive的等价方式。（但很多directive都限制为“属性”的使用方式）
							</div>
							<pre>
									<span my-dir="exp"></span>
									<span class="my-dir: exp;"></span>
									<my-dir></my-dir>
							</pre>-->
							
							<p>Attribute vs Elements directives</p>
							<pre   class="brush:js;">
									var app = angular.module("testDemoModule", []).directive('myNames', function() {
										  return {
													restrict: 'EA',
													template :'<ul><li>This is a fixture data for test!</li><li>This is also a fixture data for test!</li></ul>',
													replace:false
										  }
									});
							</pre>
							<my-Box class="fragment" boxstyle="{w:'800px',h:'30px',t:'150px',l:'20px'}"></my-Box>
							
							<div class="fragment">
									<span>
											restrict - 用来指定directive的声明方式。它的取值为EACM的子集的字符串，省略为A，directive将仅仅允许通过属性声明：
									</span>	
									<ul>
											<li>E - 元素名称： &lt;my-directive&gt;&lt;/my-directive&gt;</li>
											<li>A - 属性名： &lt;div my-directive=”exp”&gt;&lt;/div&gt;</li>
											<li>C - class名： &lt;div class=”my-directive:exp;”&gt;&lt;/div&gt;</li>
											<li>M - 注释 ： &lt;!-- directive: my-directive exp --&gt;</li>
									</ul>
							</div>
					</section>
					<!--
					TODO
					Why use directives?
					How to build a customer directives?
					AngularJS Custom Directives
					http://my.oschina.net/ilivebox/blog/289670
					
					仔细讲解Compile / link
					-->
					<section>
							<h4>Directive <span style="font-size:32px;"> -- Let AngularJs show out</span></h4>
							<p>The template</p>
							<pre   class="brush:js;">
									var app = angular.module("testDemoModule", []).directive('myNames', function() {
										  return {
													restrict: 'EA',
													template :'<ul><li>This is a fixture data for test!</li><li>This is also a fixture data for test!</li></ul>',
													replace:false
										  }
									});
							</pre>
							<my-Box class="fragment" boxstyle="{w:'800px',h:'50px',t:'180px',l:'20px'}"></my-Box>
							
							<div class="fragment">
									<span>
											<strong>template - </strong>加载directive转换DOM结构时所需要的html模板。还可以使用templateUrl引入外部html。<br/>
											<strong>templateUrl - </strong>与template基本一致，但模版通过指定的url进行加载。
									</span><br/>
									<span>
											<strong>replace - </strong> 是否用模板的html替换当前标签的html元素( <a href="./angularJs/demo/demo_direct_api.html" target="_blank">查看示例</a>):<br/>
											如果为true，则将模版内容替换当前的HTML元素，并将原来元素的属性、class一并迁移；<br/>
											如果为false，则将模版元素当作当前元素的子元素处理。<br/><br/>
									</span>
							</div>
							
							<!--Directive API -- http://www.cnblogs.com/haogj/p/3601528.html-->
							<p class="fragment">动态的数据是怎么加进来的呢？怎么储存的呢？又是怎么在html中渲染出来的呢？<!--绑定事件呢？--></p>
					</section>

				</section>

				<section class="future" style="display: none;">
						<section>
							<h4>ng-controller<span style="font-size:32px;"> -- Get AngularJs more flexible</span></h4>
							<p>MVC in AngularJs</p>
							<span>
									提到动态数据的展示，大家可能立即就会想到MVC的分层结构，因为前面已经叙述过，
									AngularJs是一个MV*的框架，那么TA也是通过控制器将model中的数据跟View绑在一起吗？
							</span>
							
							<div class="fragment">
									<p>Controller的定义</p>
									<pre   class="brush:js;">
											app.controller('helloCtr',  function() {
												//Logic goes here...
											});
									</pre>
							</div>
							
							<div class="fragment">
									<span>对Controller的引用</span>	
									<pre   class="brush:js;">
											&lt;Names  class="tag_names" ng-controller="helloCtr"&gt;
											... ...
											&lt;Names&gt;
									</pre>
							</div>
							
							<div class="fragment">
									<p>Controller对Model的引用</p>
									<pre   class="brush:js;">
											app.controller('helloCtr', ['$scope', function($scope) {
													$scope.Names= [
															{"name": "Tom","description": "This is Tom ..."},
															{"name": "Emma","description": "Emma is short for AYAMAYA ..."}
													];
											}]);
									</pre>
									<span>从示例中可以看到，Controller对Model的设定和引用是通过AngualrJs内置的服务$scope来实现的。</span>
							</div>
							
						</section>
						<section>
							<h4>ng-controller<span style="font-size:32px;"> -- Get AngularJs more flexible</span></h4>
							<p>$scope与scope</p>
							<span>
									scope是一个指向应用model的object，被放置于一个类似DOM的层次结构中。controller可以通过$scope服务对其进行访问。
									当它被嵌入到独立的应用组件中，可以为View上的表达式求值时提供上下文环境。于是我们就可以在引用了controller的DOM结构中直接访问到scope的数据。
							</span>
							<pre   class="brush:js;">
									<!--<Names  class="tag_names" ng-controller="helloCtr">{{person}}<Names>-->
							</pre>
							
							<div class="fragment">
									<p>How to display the data?</p>
									<span>
											在这个示例中，我们通过在双括号中直接使用了定义在scope中的person这样的类Javascript对象来访问数据。<br/>
									</span>
									<pre   class="brush:js;">
											<!--<Names  class="tag_names" ng-controller="helloCtr">
													<li ng-repeat="person in Names">Hello {{person.name}}!</li>
											<Names>-->
									</pre>
									<span>
											1，person.name这样的类Javascript的代码片段是AngualrJs表达式Expressions的一种。<br/>
											2，而这个双括号设定了解析表达式的绑定区域。<br/>
											3，在angular表达式里，我们不能做以下任何的事：条件分支、循环(ng-repeat)、抛出异常。<br/>
									</span>
							</div>
							
							<br/>
							<br/>
							<p class="fragment">既然scope是以js对象的方式存在，我们能通过它来传递事件吗？</p>
							
						</section>
						<section>
							<h4>ng-controller<span style="font-size:32px;"> -- Get AngularJs more flexible</span></h4>
							
							<p>Interaction -- Functions in the scope</p>
							<pre   class="brush:js;">
									app.controller('helloCtr', ['$scope', function($scope) {
											... ...
											//在scope中定义一个function
											$scope.viewDetail = function(p){
												alert(	p.description );
											}
									}]);
							</pre>
							
							<div class="fragment">
									<span>scope的结构可以是：</span><br/>
									<img src="./img/model.png" style="margin-left:200px;height:200px;"/><br/>
							</div>
							
							<div class="fragment">
								<span>怎样才能访问到这个方法呢？<!--ng-click--></span>
								<pre   class="brush:js;">
										<!--<Names  class="tag_names" ng-controller="helloCtr">
												<li ng-repeat="person in Names" ng-click="viewDetail(person)">Hello {{person.name}}!</li>
										<Names>-->
								</pre>
							</div>
						</section>
				</section>

				<section class="future" style="display: none;">
					<h4>The overall impression of Angular</h4>							
					<p>MV*<!---- We can do  more...--></p>
					
					<span>
							再回过头来看看整个<a href="./angularJs/demo/demo_code.html?img=1" target="_blank" >Demo</a>的实现，似乎controller并没有太多的业务逻辑，
							反而是很多scope数据的处理，更像是ViewModel的实现，这也是为什么AngularJs自我介绍的时候归结为MV*:
					</span>
					<div>
							<a href="./angularJs/demo/demo_code.html?img=2" target="_blank" ><img src="./img/controller.png" style="height:200px;margin-left:200px;"/></a>
					</div>
					
					
					<div class="fragment">
							<table>
									<tr>
											<td>Modules</td>
											<td>
													Where our application components live. AngularJS 的根本。
											</td>
									</tr>
									<tr>
											<td>Directives</td>
											<td>
													HTML annotations that trigger Javascript behaviors.  HTML中的声明元素，用于促发JS行为。
											</td>
									</tr>
									<tr>
											<td>Controllers </td>
											<td>
													Where we add application behavior.  控制器，起到不同层面间的组织作用。
											</td>
									</tr>
									<tr>
											<td>Views ( Expressions )</td>
											<td>
													How values get displayed within the page.
											</td>
									</tr>
							</table>
					</div>
					<br/>
					<p class="fragment">印象挺好，深入交流下，看看TA是否与众不同吧。。。</p>
				</section>

				<!--
				///////////////////////////////////////////// 入门 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part2</h1><h1>Get closer to AngularJs</h1>
					
					<!--
						<img src="./img/twoway.png" style="height:180px;margin-left:200px;"/>
						
					加入事件的讲解
					加入service的讲解
					
					关于框架的讨论
					http://segmentfault.com/blog/tychio/1190000000612397
					-->
				</section>

				<section class="future" style="display: none;">
						<section>
								<h4>What makes AngualrJs different?</h4>
								<span>
										view是用户所能看到的东西。view诞生于模版，它与model结合，最终呈现为浏览器DOM。
										AngularJs采取一个对于其他很多模版系统来说，很不一样的方式去呈现View。
								</span>
								
								<div class="fragment">
										<p>一般框架的数据绑定</p>
										<span>
												还记得前面<a href="#/2/4">jquery-tmpl 的例子</a>吗？
												和其他许多模版一样，它们通常都是通过建立带有特殊标记的HTML字符串来与数据进行连接，生成最终的HTML字符串，并将结果通过innerHTML属性写入某元素里。<br/>
										</span>
										<img src="./img/oneway.png" style="height:180px;margin-left:200px;"/><br/>
								</div>
								
								<div class="fragment">
										<span>
												<strong>存在的问题：</strong>通常这些模版标记破坏了HTML的语法；Model数据发生改变时，这个生成过程需要一次又一次地重复以更新View。<br/><br/>
										</span>
								</div>
								<p class="fragment">那么AngualrJs又是怎么实现Model和View同步更新和事件绑定的呢？</p>
								
						</section>
						<section>
								<h4>What makes AngualrJs different?</h4>
								<p>AngualrJs的解析</p>
								<span>
										<strong>Angular模版的不同之处，在于它是基于DOM的而不是基于字符串的。</strong>
										View与scope model的绑定对我们来说是透明的。 开发者无须为更新视图、model做任何动作。
								</span>	<br/>
								<img src="./img/view.png" style="height:200px;margin-left:200px;"/><br/>
								
								<span class="fragment">
										AngularJs页面的编译分为三个阶段：<br/>
										1，AngularJs编译器遍历DOM查找HTML中的directives，并会按照优先级排序加入一个指令列表中，并且他们的compile方法会被调用。
										directives的$compile()函数能修改DOM结构，并且要负责生成一个链接函数<br/>
										2，通过调用一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。 <br/>
										3，这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。
										<!--
												Angular编译器通过查询HTML中的directives处理DOM，处理结果是一个与scope model组合并生成实时模版的链接函数，
												回调这个链接函数，就可以实现一个一直更新的view，而不需要重新拼接model与template。
												首先浏览器会用它的标准API将HTML解析成DOM。 你需要认清这一点，因为我们的模板必须是可被解析的HTML。
												这是AngularJS和那些“以字符串为基础而非以DOM元素为基础的”模板系统的区别之处。
												DOM的编译是有$compile方法来执行的。 这个方法会遍历DOM并找到匹配的指令。
												一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 
												一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。 
												指令的$compile()函数能修改DOM结构，并且要负责生成一个link函数（后面会提到）。
												$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。
										-->
								</span>
						</section>
								
						<section>
								<h4>What makes AngualrJs different?</h4>
								<span></span>
								
								<p>好处 @ 1 ...</p>
								<span>
										Angular的这个处理方式，产生了一个稳定的DOM。这意味着在DOM元素的生命周期里，一直与某model的实例绑定着，这个关系不会发生改变。
										这也意味着代码可以保持对某DOM对象的引用，对其注册事件函数，并且这个引用不会被模版数据合并所销毁。<br/><br/>
								</span>	
								
								
								<div class="fragment">
										<p>好处 @2 双向绑定更加容易</p>
										<span>
												AngualrJs既然更像是MVVM的实现，如果就做到这些，那么TA也没有特别之处。 但事实上AngularJs的HTML模板 + 双向绑定的实现更简洁经典：<br/>
										</span>
										<a href="./angularJs/demo/demo_controller_twobinding.html" target="_blank"><pre   class="brush:js;">
												<!--<div>
														Your name: <input type="text" ng-model="yourname" placeholder="World"><br/>
														Hello {{ yourname }}!
												</div>-->
										</pre></a>
								</div>
								
								<p class="fragment">更多好处，有待总结 ... ...</p>
								
								
						</section>
				</section>
				
				<section class="future" style="display: none;">
						<section>
								<h4>Expression -- AngularJS's Language</h4>
								<p>AngularJs表达式</p>
								<span>
										表达式（Expressions）是类Javascript的代码片段，通常放置在绑定区域中（如｛｛expression｝｝）。<br/>
								</span>
								<a href="./angularJs/demo/demo_expression_basic.html" target="_blank"><pre  class="brush:js;">
									   <!--<div>1+2 = {{1+2}}</div>-->
									  <!-- <div ng-controller="myCtrl">Name: {{ person.name }}</div>-->
								</pre></a>
								
								<div class="fragment">
										<span>
												上述的示例很容易让人将AngularJS视图表达式联想为javascript表达式，但是angular不是通过javascript的eval()对表达式进行求值，而是内置的$parse服务解析执行。他们的区别在于：<br/>
										</span>
								</div>
								
								<div class="fragment">
										<p>@ 1 Property Evaluation</p>
										<span>
										AngularJS的表达式解析环境的上下文是scope，而javascript则是window（严格模式evel的时候）。<br/>
										AngularJS需要通过$window访问global window对象。这样做的用意是避免意外访问了公共属性（global state，a common source of subtle bugs）。
										</span>
										<a href="./angularJs/demo/demo_expression_windows.html" target="_blank"><pre  class="brush:js;">
												<!--app.controller("MyCtrl", function ($scope,$window) {
													$scope.greet = function() {
														$window.alert("Hello " + $scope.name);
													};
												});-->
										</pre></a>
								</div>
								
								<div class="fragment">
										<p>@ 2 Forgiving</p>
										<span>
												表达式求值对undefined和null是宽容的。<br>
												在javascript中，当a不是object的时候，对a.b.c求值，那么将会抛出一个异常，这对于通用语言来说是合理的。<br/>
												而表达式求值主要用于数据绑定，一般形式如下：{{a.b.c}}，如果a不存在，没有任何显示。
										</span>
								</div>
							
						</section>
						<section>
								<h4>Expression -- AngularJS's Language</h4>
								<p>@ 3 No Control Flow and '$'</p>
								<span>
									AngularJs的核心体系是应用的逻辑应当在controller（的scope）里面，而不是在view里面。
									如果我们需要在视图表达式中加入条件分支、循环或者抛出异常的话，可以委托javascript方法去代替（可以调用scope中的方法）。<br/>
									
									AngularJs为了使本身的API名称能够区别于其他的API，使用一个简单的前缀'$'以保留了特定的namespace，防止冲突。<br/><br/>
								</span>
								
								<div class="fragment">
										<p>@ 4 Using Filter</p>
										<span>
											Filters 扮演一个数据转换（格式化）的角色。他们在追随了Unix过滤器的精神与类似的语法：|  (pipe)
										</span>
										<a href="./angularJs/demo/demo_filter.html" target="_blank"><pre  class="brush:js;">
												   <!--
												   1233211234567 -> {{1233211234567|number}}//数字格式化
												   12332112.34567 -> {{12332112.34567|number:2}}//数字格式化
													{{list|filter:'text'|json}} //链式过滤器
												   -->
										</pre></a>
								</div>
								
								<br/><br/>
								
								<p class="fragment">Cool，了解下吧。。。</p>
						</section>
				<!--
					编译过程和指令匹配
					http://angularjs.cn/A00r
					
					AngularJS表达式的处理
					$parse方法
					
					http://www.cnblogs.com/lcllao/archive/2012/09/16/2687162.html
					-->
				</section>

				<section class="future" style="display: none;">
						<section>
							<h4>Filter -- AngularJS's Grammar</h4>
							<span>
									在AngularJS，Filter提供了在View端对数据进行筛选以及格式化的途径。AngularJs提供了丰富的内置Filter，同时也提供了用户自定义过滤器的途径。
							</span><br/>
							
							<div class="fragment">
									<p>built-in filters</p>
									<a href="./angularJs/demo/demo_filter.html" target="_blank"><pre  class="brush:js;">
									<!--
									currency
									{{ 123 | currency }}
									{{ 456 | currency:'USD $' }}
									date
									{{ today | date:'fullDate' }}
									{{ today | date:'shortDate' }}
									{{ today | date:'hh:mm:ss.sss' }}
									
									json
									{{ ['Ari', 'Lerner', 'Likes', 'To', 'Eat', 'Pizza'] | filter:'e' }}
									
									limitTo
									{{ "San Francisco is often cloudy" | limitTo:4 }}
									{{ ['a', 'b', 'c', 'd', 'e', 'f'] | limitTo:1 }}
									
									lowercase / 	uppercase
									{{ "I LOVE YOU" | lowercase }}
									
									number
									{{ 1234567890 | number }}
									{{ 1.234567 | number:1 }}
									
									orderBy
									{{ [{'name': 'Ari', 'status': 'awake'}, {'name': 'Nate', 'status': 'awake'}, {'name': 'Q', 'status': 'sleeping'}] | orderBy:'status':true }}
									{{ [{'name': 'Ari', 'status': 'awake'}, {'name': 'Nate', 'status': 'awake'}, {'name': 'Q', 'status': 'sleeping'}] | orderBy: '+name' }}
									-->
									</pre></a>
							</div>
						</section>
						<section>
							<h4>Filter -- AngularJS's Grammar</h4>
							
							<p>Build your own filter</p>
							<span>@ 1 -- filter the scope using $filter service </span>
							<pre class="brush:js;">
								<!--app.controller('DemoController', ['$scope', '$filter', 
									  function($scope, $filter) {
										$scope.name = $filter('lowercase')('Ari');
									}]);-->
							</pre>
							
							<div class="fragment">
									<span>@ 2 -- call the scope function </span>
									<pre class="brush:js;">
									<!-- 
									{{ ['Ari', 'likes', 'to', 'travel'] | filter:isCapitalized }}
									$scope.isCapitalized =  function(str) { return str[0] == str[0].toUpperCase(); }
									--->
									</pre>
							</div>
							
							<div class="fragment">
									<span>@ 3 -- defined your own filter </span>
									<pre class="brush:js;">
										<!--
										{{ 'ginger loves dog bones' | lowercase | capitalize }}
											angular.module('filterTestApp', []).filter('capitalize', function() {
													return function(input) {
													if (input) 
															return input[0].toUpperCase() + input.slice(1);
													} 
											});
										-->
									</pre>
							</div>
							
						</section>
					<!--
					Arrayify
					Transforms a Map into an array so that the map can be used with ng-repeat.

					Filter
					Selects a subset of items from the provided List and returns it as a new List.

					FormatterModule
					This module registers all the Angular formatters.

					Json
					Converts an object into a JSON string.

					Stringify
					Converts an object to a string.
					
					Linky
					$scope.contents = 'Text with links: http://angularjs.org/ & mailto:us@there.org';

					<div ng-bind-html="contents"></div>
					Text with links: http://angularjs.org/ & mailto:us@there.org

					<div ng-bind-html="contents | linky"></div>
					The linky filter goes through the text contents and adds <a> tags to all URLs and mailtolinks it finds, thus providing HTML content that the user can interact with:
					Text with links: http://angularjs.org/ & us@there.org
					-->

				</section>

				<section class="future" style="display: none;">
					<section>
							<h4>Scope  -- AngularJS's Memory</h4>
							<span>
									<a href="#/7/1">前面</a>提到过，scope是被放置于一个类似应用的DOM结构的层次结构中。<br/>
									而在<a href="#/10/1">AngualrJs的解析</a>中也提到，每一个Directive都能对DOM注册监听事件。正是scope负责检测model的变化，为表达式的执行提供execution context，传播事件。<br/>
							</span><br/>
							
							<div class="fragment">
									<p>scope的特性</p>
									<ul>
											<li>scope提供$watch API，用于监测model的变化。</li>
											<li>scope提供$apply API，在 controller、server、angular event handler 之外，从系统到视图传播任何model的变化。</li>
											<li>scope可以在通过原型，从parent scope中继承属性。</li>
											<li>scope在expression求值之时提供上下文环境。例如，{{username}}表达式是无意义的，除非它与一个特定的定义了”username”属性的scope一起进行求值。</li>
									</ul>
							</div>
							
							<div class="fragment">
								<span>
									关于第三点，下面的例子展示“name”这个表达式的值查找的方式：
								</span>
								<a href="./angularJs/demo/demo_scope.html" target="_blank"><pre   class="brush:js;">
										<!--
											<div class="ng-cloak" ng-controller="ControllerB"> Hello {{name}}!;
												<div class="ng-cloak" ng-controller="ControllerC"> Hello {{name}}!;
													<div class="ng-cloak" ng-controller="ControllerD">Hello {{name}}!;</div> //D中不定义任何的scope
												</div>
											</div>-->
								</pre></a>
							</div>
					</section>
					
					
					<section>
							<h4>Scope  -- AngularJS's Memory</h4>
							<p>Scope as Data-Model</p>
							<span>scope是在应用controller与view之间的纽带。
									<!--在模版linking的阶段，directive在scope中设置$watch表达式。
									$watch让directive能够得知属性的变化，使得directive将更新后的值渲染到DOM中。-->
									controller和directive两者都与scope有引用，但它们两者之间没有（引用）。
									这样的安排，将controller从directive和DOM中隔离开来。
									这是一个重要的地方，因为它让controller与view是隔离的，极大地提升了应用的可测试性。
							</span>
							<a href="./angularJs/demo/demo_controller_twobinding.html" target="_blank"><pre   class="brush:js;">
									<!--		
									// Directive View :  
									<div ng-controller="MyController">
											Your name: <input type="text" ng-model="username" placeholder="World"><br/>
											Hello {{username || 'World'}}!<br/>
											{{greeting}}
											<button ng-click="sayHello()">欢迎</button>
									</div>
									
									// Controller :  
									$scope.username = "My Little Dada";
									$scope.sayHello = function() {
											$scope.greeting = "Hello~" + $scope.username + "!";
									};
									-->
							</pre></a>
							<my-Tips  class="fragment" tips="{
									contents : 'MyController以My Little Dada对scope中的username属性进行赋值，scope通知input进行赋值，将username的值预先填入input中。',
									style:{direction:'l',position:{top:'440px',left:'430px'}}
							}"> </my-Tips>
							<my-Tips  class="fragment" tips="{
									contents : 'controller可以将行为附加在scope中，sayHello方法可以读取username属性，也可以创建greeting属性。当它们绑定到HTML input控件时，scope中的属性会自动更新。',
									style:{direction:'l',position:{top:'270px',left:'430px'}}
							}"> </my-Tips>

							<span class="fragment">
									逻辑上，显示｛｛greeting｝｝涉及以下两点：<br/>
									与定义了｛｛greeting｝｝表达式的模版DOM节点一起检索scope。(本例与传递到MyController中的scope是相同的。)<br/>
									通过之前检索的scope，对greeting表达式进行求值，然后将结果作为封闭DOM元素的text的值。<br/>
							</span>
							<my-Tips  class="fragment" tips="{
									contents : 'scope和它自己的属性可以作为数据，用于渲染视图。从可测试性来看，controller和view的分离是值得欣喜的，',
									style:{direction:'t',position:{top:'600px',left:'130px'}}
							}"> </my-Tips>
							
							
					</section>
					<section>
							<h4>Scope  -- AngularJS's Memory</h4>
							<span>回顾前面的例子，我们不难发现，有时候我们并没有定义scope。比如那些没有定义Controller的示例中，scope在哪里？</span>
							
							<div  class="fragment">
									<p>scope层次结构</p>
									<ul>
											<li>每一个angular应用有且只有一个root scope，但可以拥有多个child scope，因为一些directive会创建新的child scope。附加到的DOM的root scope的位置是通过ng-app directive的位置定义的。</li>
											<li>当新的scope被创建后，他们将作为一个child scope，加入到parent scope中。这样，创建了一个与它们附属的DOM相似的树结构。</li>
											<li>当angular对{{username}}求值时，它首先查看与当前元素关联的scope的username属性。如果没有找到对应的属性，它将会一直向上搜索parent scope，直到到达root scope。</li>
									</ul>
							<div>
							
							<span  class="fragment">
									一些directive会创建新的child scope，那么哪些directive可创建新的scope的呢？
							</span>
							<div  class="fragment">
									<pre   class="brush:js;">
											<!--<li ng-repeat="person in Names">Hello {{person.name}}!</li>-->
									</pre>
									<span>ng-repeat为Names创建了多个person的child scope。</span>
							</div>
							<br/>
							<br/>
							<p  class="fragment">
									多个directive使用同样的controller，如何使用独立的scope呢？
							</p>
							
					</section>
					<section>
							<h4>Scope  -- AngularJS's Memory</h4>
							<p>isolate scope</p>
							<pre   class="brush:js;">
									<!-- //Directive 
									var app = angular.module("testDemoModule", []).directive('myTips', function() {
										  return {
													restrict: 'EA',
													template :'<div style="top: {{ tips.style.position.top }};left: {{tips.style.position.left}};"> </div>',
													scope:{
														tips : "=tips"
													}
										  }
										}).controller('myTipsCtr', ['$scope', function($scope) {
												$scope.tips1={contents : 'This is a test 1 !',style:{direction:'r',position:{top:'100px',left:'150px'}}};
												$scope.tips2={contents : 'This is a test 2 !',style:{direction:'r',position:{top:'10px',left:'50px'}}};
										}]);
									<my-Tips tips="tips1"> </my-Tips>
									<my-Tips tips="{ contents : 'this is tip one', style:{direction:'t',position:{top:'240px',left:'100px'}}}"> </my-Tips>
									-->
							</pre>
							<my-Box class="fragment" boxstyle="{w:'800px',h:'80px',t:'230px',l:'20px'}"></my-Box>
							
							<!--<div  class="fragment">
								<p>scope生命周期</p>
								<span>
								
								</span>
							<div>
							
							<div  class="fragment">
								<p>Scope事件传播</p>
								<span>
								
								</span>
							<div>-->
					</section>
										
					<!--
					$rootScope
					How Model works -- $scope & scope
					
					AngularJs学习笔记--Scope/ scope的生命周期
					http://www.cnblogs.com/lcllao/archive/2012/09/23/2698651.html
					
					
					-->
				</section>

				<section class="future" style="display: none;">
					<section>
							<h4>Service  -- AngularJS's Tools</h4>
							<span>
								在前面的例子中，我们几次提到了AngularJs的service，比如$scope，在ng-app加载的过程一直在默默工作。
							</span>
							<pre   class="brush:js;">
									<!--
									var app = angular.module("testDemoModule", []).controller('myTipsCtr', ['$scope', function($scope) {
										... ...
									}]);	-->
							</pre>
							<span class="fragment" >
									在上面的示例中，当我们新建myTipsCtr时，用参数数组的方式添加了$scope的引用，
									在AngularJs中我们称为“依赖注入”，而AngularJs实现依赖注入的方式也是通过$Injector这个服务实现的。
							</span>
							
							<img class="fragment"  src="./img/Injector.png" style="margin-left:200px;"/><br/>
							<span class="fragment" >
									1，所有的AngularJs服务都是实现为单例模式，并注册在依赖注入系统中。<br/>
									2，当AngularJs启动时，Controller开始启动构造的时候，通过参数指出依赖。<br/>
									3，AngularJS的依赖注入系统帮你查找左右依赖，负责实例化，并且按照工场函数要求的样子传递依赖。<br/>
							</span>
					</section>
					<!--<section>
							<h4>Service  -- AngularJS's Tools</h4>
							<p>Create your own service</p>
							<span>
								Service就是【单例对象】在AngluarJS中的一个别名。这些单例对象会被经常传来传去，保证你每次访问到的都是同一个实例，
								基于这个特性，单例对象让我们可以实现一些相当酷的功能，它可以让很多controller和directive访问内部的数值。
							</span>
							<pre   class="brush:js;" class="fragment" >
							var app = angular.module( "myModule", [] );
								app.service( 'Book', [ '$rootScope', function( $rootScope ) {
									var service = {
										books: [ { title: "Magician", author: "Raymond E. Feist" },{ title: "The Hobbit", author: "J.R.R Tolkien" } ],
										addBook: function ( book ) {
												service.books.push( book );
										}
									}
									return service;
							}]);
							</pre>
							<span></span>
							<pre   class="brush:js;" class="fragment" >
							
									var ctrl = [ '$scope', 'Book', function( scope, Book ) {
											scope.$on( 'books.update', function( event ) {
													scope.books = Book.books;
											}); 
											scope.books = Book.books;
									 }];
									 app.controller( "books.list", ctrl );//使用我们的服务
							</pre>
					</section>-->
					<section>
							<h4>Service  -- AngularJS's Tools</h4>
							<p>$http - the communication system</p>
							<span>在angularJS中与远程HTTP服务器交互时会用一个非常关键的服务-$http。</span>
							<pre   class="brush:js;">
									<!--$http.get('testurl').success(function(data) {
											$scope.phones = data;
									});-->
							</pre>
							
					</section>
					<!--
					理解服务
					http://angularjs.cn/A00R
					AngularJS服务是一种能执行一个常见操作的单例，比如$http服务是用来操作浏览器的XMLHttpRequest对象的。

					要使用AngularJS服务，你只需要在需要的地方（控制器，或其他服务）指出依赖就行了。AngularJS的依赖注入系统会帮你完成剩下的事情。它负责实例化，查找左右依赖，并且按照工场函数要求的样子传递依赖。

					AngularJS通过“构造器注入”来注入依赖（通过工场函数来传递依赖）。以为Javascript是动态类型语言，AngularJS无法通过静态类型来识别服务，所以你必须使用$inject属性来显式地指定依赖。比如:formatDate

					myController.$inject = ['$location'];
					AngularJS web框架提供了一组常用操作的服务。和其他的内建变量或者标识符一样，内建服务名称也总是以"$"开头。另外你也可以创建你自己的服务。

					-->

					<!--
					why need a service?
					-->

					<!--
					How to build a customer Service?
					创建服务：应该从通过一个模块（module）注册一个服务工厂方法开始（可以使用Module#factory api或者直接使用模块配置方法中的$provide api）。
					angular.service('PostService', function ($http) {
							var posts = {};
							return {
									getById: function (id) {
											if (!posts[id]) {
													this.find(id)
											}; 
											return posts[id]; 
									},
									find: function (id) {
											return $http.get('posts/' + id).then(function (data) {
													posts[id] = data;
													return data;
											});
									}
							};
					}); 
					
					
					注册服务：注册带有通过Module Api的模块的服务
					var myModule = angular.module('myModule', []);
					myModule.factory('serviceId', function() {
							var shinyNewServiceInstance;
							//factory function body that constructs shinyNewServiceInstance
							return shinyNewServiceInstance;
					});
					注册服务：注册在模块配置方法中使用$provide服务的模块
					angular.module('myModule', [], function($provide) {
							$provide.factory('serviceId', function() {
									var shinyNewServiceInstance;
									//factory function body that constructs shinyNewServiceInstance
									return shinyNewServiceInstance;
							});
					});
					注册服务：你不是在注册一个服务实例，而是工厂方法将会在创建服务实例的时候被调用。

					http://angularjs.cn/A00N

					http://www.cnblogs.com/sitemanager/p/3459941.html
					http://www.cnblogs.com/sitemanager/archive/2013/12/05/3459516.html
					http://www.cnblogs.com/sitemanager/p/3459516.html
					
					使用Angular 服务：使用inject
					var MyController = function($location) { ... };
					MyController.$inject = ['$location'];
					myModule.controller('MyController', MyController);
					使用Angular 服务：提供一个内联的注入“注释”：
					var myService = function($http) { ... };
					myModule.factory('myService', ['$http', myService]);
					
					
					-->

					<!--
					服务依赖：服务不仅仅可以被依赖，还可以有它们自己的依赖。这些依赖能够被作为工厂方法的参数指定。
					angular.module('myModule', [], function($provide) {
							$provide.factory('notify', ['$window', function(win) {
									var msgs = [];
									return function(msg) {
											msgs.push(msg);
											if (msgs.length == 3) {
													win.alert(msgs.join("\n"));
													msgs = [];
											}
									};
							}]);
					});
					
					-->
					
					<!--
					How does Controller use a service?
					//Dependency Injection!

					将服务注入到控制器中
					实例化AngularJS的服务
					
					http://angularjs.cn/A00O
					
					image  --	Module & Injector (1).png

					管理服务依赖
					http://angularjs.cn/A00P
					声明依赖，
					在工场方法参数中隐式指明他们，
					也可以将$inject属性设置成包含了依赖名称的数组，(不推荐使用)
					或者是使用数组表示法。

					几点要注意：
					自定义的服务都使用隐式表示和数组法来表示自己的依赖。
					最重要的是数组中的服务的名字顺序要和工厂函数参数的名字顺序对应。
					除非依赖是隐式地通过函数参数名表示的，那么就是有声明依赖的数组名称顺序决定依赖注入的顺序。
					-->

					<!-- Example :
					$http
					-->

					<!--
					$http
					$timeout
					$log
					$route

					-->

				</section>
				
				<!--
				///////////////////////////////////////////// 应用 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part3</h1><h1>Interested in AngularJs</h1>
					
				</section>

				<section class="future" style="display: none;">
					<h4>Form</h4>

					<!--
					实现自定义的表单控件
					http://angularjs.cn/A00t
					-->
					<!--
					validate
					-->
				</section>

				<section class="future" style="display: none;">
					<h4>File Upload in AngularJS</h4>

				</section>
				

				<section class="future" style="display: none;">
					<h4>路由与多视图</h4>
					<!--
					http://blog.fens.me/angularjs-route-template/
					http://blog.csdn.net/violet_day/article/details/16974467
					http://scotch.io/tutorials/javascript/single-page-apps-with-angularjs-routing-and-templating
					http://scotch.io/tutorials/javascript/animating-angularjs-apps-ngview
					http://www.2cto.com/kf/201312/265979.html
					
					以jQuery的思路，做响应式的架构设计时，我们要监听所有点击事件，通过事件函数触发我们加载数据，提交，弹框，验证等的功能；
					以 AngularJS的思路，做声明式的架构设计时，我们通过指令和路由先设定好，什么样的操作干什么事情，等事件发生时，程序就会知道该干什么了。
					
					-->
					
					<!--
					走进AngularJs(八) ng的路由机制
					
					在谈路由机制前有必要先提一下现在比较流行的单页面应用，就是所谓的single page APP。
					为了实现无刷新的视图切换，我们通常会用ajax请求从后台取数据，然后套上HTML模板渲染在页面上，
					然而ajax的一个致命缺点就是导致浏览器后退按钮失效，尽管我们可以在页面上放一个大大的返回按钮，让用户点击返回来导航，但总是无法避免用户习惯性的点后退。
					解决此问题的一个方法是使用hash，监听hashchange事件来进行视图切换，
					另一个方法是用HTML5的history API，通过pushState()记录操作历史，监听popstate事件来进行视图切换，也有人把这叫pjax技术。基本流程如下：
					<img src="pjax.png"/>
					　如此一来，便形成了通过地址栏进行导航的深度链接（deeplinking ），也就是我们所需要的路由机制。通过路由机制，一个单页应用的各个视图就可以很好的组织起来了。

					
					AngularJS路由功能是一个纯前端的解决方案，与我们熟悉的后台路由不太一样。
					后台路由，通过不同的URL会路由到不同的控制器上(controller)，再渲染(render)到页面(HTML)。
					AngularJS的前端路由，需求提前对指定的(ng-app)，定义路由规则(routeProvider)，然后通过不同的URL，告诉(ng-app)加载哪个页面(HTML)，再渲染到(ng-app)视图(ng-view)中。
					AngularJS的前端路由，虽然URL输入不一样，页面展示不一样，其实完成的单页(ng-app)视图(ng-view)的局部刷新。
					这样来看，AngularJS做单页应用就有点标配的感觉了。
				-->


				<!--	
					ngRoute包括的内容
					ng的路由机制是靠ngRoute提供的，通过hash和history两种方式实现了路由，可以检测浏览器是否支持history来灵活调用相应的方式。ng的路由(ngRoute)是一个单独的模块，包含以下内容：
						服务$routeProvider用来定义一个路由表，即地址栏与视图模板的映射
						服务$routeParams保存了地址栏中的参数，例如{id : 1, name : 'tom'}
						服务$route完成路由匹配，并且提供路由相关的属性访问及事件，如访问当前路由对应的controller
						指令ngView用来在主视图中指定加载子视图的区域
						　　以上内容再加上$location服务，我们就可以实现一个单页面应用了。下面来看一下具体如何使用这些内容。
	
			
使用ng的路由机制
　　第一步：引入文件和依赖
　　ngRoute模块包含在一个单独的文件中，所以第一步需要在页面上引入这个文件，如下：
 
<script src="http://code.angularjs.org/1.2.5/angular.min.js"></script>
<script src="http://code.angularjs.org/1.2.5/angular-route.min.js"></script>
　　光引入还不够，我们还需在模块声明中注入对ngRoute的依赖，如下：
 
var app = angular.module('MyApp', ['ngRoute']);
　　完成了这些，我们就可以在模板或是controller中使用上面的服务和指令了。下面我们需要定义一个路由表。
 
　　第二步：定义路由表
　　$routeProvider提供了定义路由表的服务，它有两个核心方法，when(path,route)和otherwise(params)，先看一下核心中的核心when(path,route)方法。
 
　　when(path,route)方法接收两个参数，path是一个string类型，表示该条路由规则所匹配的路径，它将与地址栏的内容($location.path)值进行匹配。如果需要匹配参数，可以在path中使用冒号加名称的方式，如：path为/show/:name，如果地址栏是/show/tom，那么参数name和所对应的值tom便会被保存在$routeParams中，像这样：{name : tom}。我们也可以用*进行模糊匹配，如：/show*/:name将匹配/showInfo/tom。
 
　　route参数是一个object，用来指定当path匹配后所需的一系列配置项，包括以下内容：
 
controller //function或string类型。在当前模板上执行的controller函数，生成新的scope
controllerAs //string类型，为controller指定别名
template //string或function类型，视图所用的模板，这部分内容将被ngView引用
templateUrl //string或function类型，当视图模板为单独的html文件或是使用了<script type="text/ng-template">定义模板时使用
resolve //指定当前controller所依赖的其他模块
redirectTo //重定向的地址
　　最简单情况，我们定义一个html文件为模板，并初始化一个指定的controller：
 
 
function emailRouteConfig($routeProvider){
    $routeProvider.
    when('/show', {
        controller: ShowController,
        templateUrl: 'show.html'
    }).
    when('/put/:name',{
       controller: PutController,
       templateUrl: 'put.html'
    });  
};
 
　　otherwise(params)方法对应路径匹配不到时的情况，这时候我们可以配置一个redirectTo参数，让它重定向到404页面或者是首页。
 
　　第三步：在主视图模板中指定加载子视图的位置
　　我们的单页面程序都是局部刷新的，那这个“局部”是哪里呢，这就轮到ngView出马了，只需在模板中简单的使用此指令，在哪里用，哪里就是“局部”。例如：
 
<div ng-view></div>
　　或：
 
<ng-view></ng-view>
　　我们的子视图将会在此处被引入进来。完成这三步后，你的程序的路由就配置好了。

-->


<!--

					
					AngularJS中locationchange、routechange事件
					http://blog.csdn.net/spy19881201/article/details/17096675
					假设有这样一场景：在用户切换到另外一个route时，需要检查当前表单（内容）是否已保存？考虑下在AngularJS中如何实现？
					我们首先来分析下，场景中有那些事件流。
					①：用户编辑了表单
					②：用户准备点击另外一个route url，触发提示‘是否要保存’
					③：点击‘是’，route切换事件停止；点击‘否’，route切换事件继续
					主要流程就这些其实很简单。
					这里主要涉及到了AngularJS中的事件处理模块。
					首先我们需要知道的是$locationChangeStart和$routeChangeStart哪个事件先触发。
					route是监控location.url的，然后采取操作的。
					所以事件的触发应该是先location后route事件
					我们只需要处理 locationChangeStart，
					我们利用location改变事件来实现了在提交Location之前做了定制化，除了location事件，还有route事件，利用route事件我们可以做‘loading..’效果。

					
					
					-->
					
				</section>
				

				<section class="future" style="display: none;">
					<h4>Animation</h4>
					<!--
					AngularJS开发指南-Animations
					http://www.tuicool.com/articles/jEvY3a
					
					AngularJS自1.2版本起，可以在一些常用的directive上绑定animation，比如ngRepeat, ngSwitch和ngView，也可以在自定义的directive上绑定animation（使用$animation）。
					在使用了某些directives的元素的生命周期中，能够通过一些animation的钩子来触发animation事件，当触发时，会表现出动画效果（动画效果通过css或javascript定义）。
					可以使用纯css（遵循AngularJS中的一些规范）或者javascript代码（定义在服务中）来设置animation。
					
					它的方式是比如你用angular的ng-hide，想使它有动画效果。在你把ng-animate引入并加载模块后，它会把ng-hide分成ng-in,ng-in-active,ng-leave,ng-leave-active四个阶段。
					当检测到数据变化触发ng-hide的时候会依次给这个dom增加这四个class，你的动画效果就写在这四个class里。
					
					在我使用的时候我发现很不精细，比如我不能控制一堆的ng-hide是从上倒下动画隐藏呢还是从下到上，
					而且这中间如果你想让这些ng-hide动画一依次进行还必须除了上面四个class外再加一个它指定的class，还只能匀速。
					我看了它的源码，依次进行的效果是通过setinterval进行的…
					
					The ngAnimate module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.
					Keep in mind that if an animation is running, any child elements cannot be animated until the parent element's animation has completed.
					
					哪些指令（directive）支持animation？
					一少部分常用的directives在它们的生命周期中，任何时间都支持并能够触发animation绑定。
						ngRepeat	enter, leave and move
						ngView	enter and leave
						ngInclude	enter and leave
						ngSwitch	enter and leave
						ngIf	enter and leave
						ngClass or	enter and remove
						ngShow&ngHide	enter and remove
					
					-->
					
					<!--
					使用Animation前，需要在你的应用中添加对ngAnimate Module的依赖。
					
					Animation在angular中完全基于css。只要为元素添加一个css类型，就可以在此元素上应用animation。
					
					JavaScript-defined Animations
					ng-repeat
					在此使用ng-repeat的模板中，当在items中新增一项时，ngRepeat会为新产生的元素添加一个ng-enter类；
					当删除一项时会为将被删除的元素添加一个ng-leave类，当元素交换位置时，回为响应元素添加ng-move类。
					
					ng-hide/ng-show
					
					 使用javascript可以实现相同的动画效果
					 如果为一个元素同时定义了css动画和javascript动画，则AngularJS会同时执行这两个动画。
					--->
					
					<!--
					CSS-defined Animations
					class和ngClass动画绑定

					当元素的类（class）发生变化时，angular可以通过触发绑定的add和remove来添加动画效果。
					这句话的意思是，当一个元素绑定或删除某个class时，在该class被添加或移除的过程中，AngularJS可以触发响应的动画效果
					（注意：AngularJS只能捕获到通过表达式或ng-class改变的class）
					
					
					CSS Staggering Animations
					--->
					
					<!--
					在自定义的directives中使用animation
					$animate service
					
					-->
					
				</section>


				<!--
				///////////////////////////////////////////// 理解 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part4</h1><h1>Fall in LOVE with AngularJs</h1>
					<!--
					- 深入实现（ 实现原理，实战）
					-->
				</section>

				<section class="future" style="display: none;">
					<h4>How AngularJS Starts up in your browser?</h4>

					<!--
					http://angularjs.cn/A00q
					-->
					<!--

					<img src="./img/startup.png"/>

					下面描述angular是如何启动的（参考图表与下面的例子）：

					1. 浏览器加载HTML，将HTML标签转换为DOM对象；

					2. 浏览器加载angular.js的脚本；

					3. Angular等待DOMContentLoaded事件；

					4. Angular寻找ng-app这个用于指定应用边界范围的directive；

					5. 如果ng-app有指定module（也许是ng-app=”SomeApp”），将被用作配置$injector；

					6. $injector用于创建$compile服务（service）以及$rootScope；

					7. $compile服务用作“编译”（有点像遍历，然后做一点神秘的事情）DOM，并将其与对应的$rootScope连接。

					8. ng-init 这个directive在对应的scope中创建name属性并对其赋予”Kitty”值；

					9. 将“{{name}}”的值插入(interpolates)到表达式中，最终显示”Hello Kitty!”。
					-->

					<!---
					ng-app指令：
					<html lang="en" ng-app>
					ng-app指令标记了AngularJS脚本的作用域，在<html>中添加ng-app属性即说明整个<html>都是AngularJS脚本作用域。开发者也可以在局部使用ng-app指令，如<div ng-app>，则AngularJS脚本仅在该<div>中运行。
					-->

					<!---
					<pre>
					<html lang="zh-cn" ng-app>
					<head>
					<meta charset="UTF-8">
					<title>Hello Kitty!</title>
					<style type="text/css">
					.ng-cloak {
					display: none;
					}
					</style>
					</head>
					<body>
					<div ng-init="name='Kitty'">Hello {{name}}!</div>
					<script src="../angular-1.0.1.js" type="text/javascript"></script>
					</body>
					</html>
					</pre>
					-->

				</section>

				<section class="future" style="display: none;">
					<h4>HTML编译器——$Compiler</h4>

					<!--
					放在后面讲
					Angular编译器（html compiler）
					-->
					
					<!--
					是的，又是一个模板引擎，这种低级轮子竟然还有人造，在朋友你反驳之前，请先容我挣扎以下。

					Regularjs是一个结合了字符串模板和*dom模板的优点的活动模板引擎(living template engine)*， 准确的说这个模板引擎的parser部分是基于字符串的而compiler部分是基于Dom的。而普遍市面上的模板不是纯粹基于字符串就是纯粹基于dom.

					首先先回答两个基本问题。

					什么是基于字符串的模板？
					例子: ejs、handlebar、jade等 特点是有独立的parser来处理特有的语法，它的一般工作原理是

					parse 字符串模板， 输出中间状态 (函数或者ast->函数)
					输入data，生成字符串，输出之后数据data与输出字符串不再有关联
					插入字符串到指定位置(innerHTML等)
					特点是: 1. 语法灵活，自由度高，只输出必要的部分 2. compile之后数据与输出不再关联，即它是"死的"

					什么又是基于Dom的模板？
					例子: angularjs, knockoutjs, avalonjs等

					特点是没有自己的parse过程，一般工作原理是

					将模板字符串插入到dom中，生成初始dom结构
					自顶向下遍历输出的dom结构，提取指令事件等信息(通过getAttribute)，改写dom结构(link)或形成绑定关系
					输入数据data, 根据绑定关系触发dom结构变化(这一步可能与步骤2同时进行)
					其实纯粹的dom-based的库其实不能称之为模板引擎. 它的特点是:

					无parse，需要利用停留在初始dom结构上的属性信息来处理业务逻辑, 逻辑能力普遍基于指令或类似的定义，灵活度低。
					生成的dom仍与data有关联，即是“活的”
					
					什么又是活动模板引擎
					简而言之，是基于字符串的parser + 基于dom的comiper，它的一般工作原理是

					输入字符串模板 ，输出AST结构，例如regularjs的中间结构示例
					[
					{
					"type": "list",
					"sequence": {
					"type": "expression",
					"body": "_d_['items']",
					"constant": false,
					"setbody": "_d_['items']=_p_"
					},
					"variable": "item",
					"body": [
					... for short ...
					]
					
					compiler利用AST里包含的完整信息，逐级创建节点并组装成dom结构. 并实现绑定关系
					输入data，根据数据-模板对应关系，最小化更新节点。
					这种模板结合了字符串模板和dom模板的优势，只需要需要输出的内容，不会留不必要的placeholder在节点上(输入后右键查看元素: angularjs, regularjs),并且贴合了以前使用模板引擎的习惯，拥有完全自治的生命周期可以无缝与你正在使用框架继承(包裹angularjs)。
					-->



					<!--

					Compiler作为Angular的一个服务（Service），负责遍历DOM结构，寻找属性。编译过程分成两个阶段：

					1. 编译（Compile）：遍历DOM节点树，收集所有directives。返回结果是一个链接函数（linking function）。

					2. 链接（Link）：将directives绑定到一个作用域（scope）中，创建一个实况视图（live view）。在scope中的任何改变，将会在视图中得到体现（更新视图）；任何用户对模版的活动（改变），将会体现在scope model中（双向绑定）。这使得scope model能够反映正确的值。

					一些directives，诸如ng-repeat，会为每一个在集合（collection）中的元素复制一次特定的元素（组合）。编译和链接两个阶段，使性能得以提升。因为克隆出来的模版(template)只需要编译一次，然后为每一个集合中的元素进行一次链接（类似模版缓存）。

					-->

					<!--
					angular指令的compile的参数(tElement,tAttrs)和link中的参数(scope,iElement,iAttrs)究竟有什么区别?
					http://segmentfault.com/q/1010000000664866

					ng指令中的compile与link函数解析
					http://www.ifeenan.com/angularjs/2014-09-04-%5B%E8%AF%91%5DNG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/
					-->


								<span>
									原理思路举例：
									Q:既然是基于DOM的，那么生成DOM的属性如何实现动态绑定呢？ 比如image的src， a标签的herf，再解析的时候设定好，
									A:加标记使之进入Compiler的查找范围，
									已经有了内置的ng-src
								</span>
								
								
					<!--
					关于Compile、PreLink、PostLink和Controller的关系与区别
					http://angularjs.cn/A0pa

					一般运行次序：

					Compile（一次）[子指令的Compile...]>Controller（多次）>PreLink（多次）[子指令的Controller>子指令的PreLink[>子子指令的Controller...]...]>PostLink（多次）

					如果有子指令依赖父指令的Scope的，次序会变成：

					Compile（一次）>Controller（多次）>PreLink（多次）>PostLink（多次）[子指令...]

					（另外，有指令嵌套的情况下，参数replace为true或false也会导致运行次序不同，不过一般都是Compile>Controller>PreLink>PostLink，大家有空可以看看这个《【点滴积累】嵌套directive中的replace 对 初始化顺序的影响》）

					Compile: 用于收集指令，编译模板，可以作用到所有的子指令，然后返回一系列的link函数等待执行（只运行一次）；

					PreLink: 运行于Compile之后但是在子指令关联之前，个人认为，这里可以做一些Scope的计算或赋值之类的，然后再去绑定，此时由于DOM尚未绑定，进行DOM变形将有可能导致运行异常，不建议在此阶段进行（运行多次）；

					PostLink: 主要用于绑定DOM和Scope，这时候可以进行DOM变形或绑定事件。其实PostLink就是Link（运行多次）；

					Controller: 主要用于与其他指令交互，可以在上面定义一些函数来操作Scope等（运行多次）；

					关于transclude，可以看看这个《Transclude in AngularJS》（http://blog.omkarpatil.com/2012/11/transclude-in-angularjs.html）;
					-->
templateUrl - 与template基本一致，但模版通过指定的url进行加载。因为模版加载是异步的，所以compilation、linking都会暂停，等待加载完毕后再执行。
					<!--
					ng指令中controller与link的区别
					http://angularjs.cn/A0nR

					http://jasonmore.net/angular-js-directives-difference-controller-link/

					
					
					在angular中model的渲染完成是在directive的link函数执行以后的。
					
					-->

				</section>


				<!--
				///////////////////////////////////////////// 深入 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part5</h1><h1>Fascinated with angularjs</h1>
				</section>

				<section class="future" style="display: none;">
					<h4>ng运行与指令 </h4>

					<!--

					Directive Definition Object 指令定义对象
					http://angularjs.cn/A00p

					-->
					<!--
					link: function(scope, element, attrs) {
					var optionsObj = {
					dataType: 'json'
					};
					if (scope.done) {
					optionsObj.done = function() {
					scope.$apply(function() {
					scope.done({e: e, data: data});
					});
					};
					}
					if (scope.progress) {
					optionsObj.progress = function(e, data) {
					scope.$apply(function() {
					scope.progress({e: e, data: data});
					});
					}
					}
					// the above could easily be done in a loop, to cover
					// all API's that Fileupload provides
					element.fileupload(optionsObj);
					}-->
				</section>

				<section class="future" style="display: none;">
					<h4>Modules and the Injector</h4>

					<!--
					http://www.cnblogs.com/lcllao/archive/2012/09/07/2671227.html

					<img src="./img/Module & Injector.png"/>
					Injector是一个服务定位器。每一个Angular应用，都会有一个单独的injector。Injector提供一个通过名称查找对象实例的途径。Injector会在内部cache中保持所有对象实例，所以重复调用相同的名称时，返回的都是同一个对象实例。如果对象不存在，那么它会请求实例工厂（instance factory）去创建一个新实例。

					Module是一个配置injector的实例工厂的方法，被称为”provider”。

					但是injector的真正牛X的地方在于它可以用于调用方法和”instantiate” type。这个美妙的特性是允许method和types请求他们所依赖的资源，而不是寻找他们。

					注意，我们唯一需要写的，就是我们的function，在function的arguments中列出方法依赖的资源即可！当angular调用function时，他会使用”call”方法，自动填充function agruments。

					留意下面的例子中是如何在constructor中列出依赖的。当ng-controller实例化controller时，将自动提供所依赖的资源。没有必要去创建、寻找、创建injector引用来加载依赖资源。

					-->

					<!--
					Factory method工厂函数   与 $Injector
					http://angularjs.cn/A00r

					工厂函数是用来创建指令的。它只会被调用一次：就是当编译器第一次匹配到相应指令的时候。你可以在其中进行任何初始化的工作。调用它时使用的是 $injector.invoke ， 所以它遵循所有注入器的规则。
					
					
					首先我们来谈论下注册指令的API，跟controller一样，指令是注册在module上，不同的是，指令是通过module.directive API来注册的。module.directive接受的是一个规范化的名字和工厂函数，这个工厂函数返回一个包含不同配置的对象，这个对象用来告诉$compile服务如何进行下一步处理。
					工厂函数仅在编译器第一次匹配到指令的时候调用一次。通常在工厂函数中执行初始化的工作。该函数使用$injector.invoke调用，所以它可以像controller一样进行依赖注入。
					
					-->

				</section>

				<section class="future" style="display: none;">
					<h4>Event Loop</h4>

					<!--
					JavaScript 运行机制详解：什么是Event Loop
					http://www.ruanyifeng.com/blog/2013/10/event_loop.html
					JavaScript 运行机制详解：再谈Event Loop
					http://www.ruanyifeng.com/blog/2014/10/event-loop.html
					-->

					<!--
					<img src="./img/startup.png"/>
					这图表和后面的例子，描述了angular如何通过浏览器event-loop（所有的时间处理函数，以及timer执行的函数，会排在一个queue结构中，利用一个无限的循环，不断从queue中取出函数来执行，这个就是event-loop。来自http://wiki.nodejs.tw/nodejs_from_scratch/javascript-yunodejs/2-1-event-loop）来进行交互。

					1. 浏览器event-loop等待事件到来。事件来自于用户交互（DOM events）、timer事件（setTimeout）、network事件（服务端响应，XHR之类）；

					2. 事件回调函数开始执行。这里进入javascript上下文（context）。这回调函数可以修改DOM结构。

					3. 当回调函数执行完毕后，浏览器退出javascript context，根据DOM的改变来重绘视图。

					Angular通过创建自己的事件处理循环（event processing loop），修改了一般的javascript流（flow）。这将Javascript分割成传统的和Angular的执行上下文（execution context）。只要是在Angular execution context 里面执行的操作，都拥有angular data-binding、异常处理（exception handling）、属性监视（property watching）等能力。我们可以通过在javascript使用$apply()，进入Angular execution context。但要记住一点，在大多数（angular的）地方（如controllers、services），处理事件的directive会为你调用$apply。手动调用$apply的场景，一般是当你实现自定义事件处理函数，或者处理第三方库的回调的时候。

					1. 通过调用scope.$apply(stimulusFn)进入angular execution context。stimulusFn就是我们想在angular execution context中执行的函数（含scope作为参数）或者angular合法的表达式。

					2. Angular执行stimulusFn，这通常会改变应用的状态（application state）。

					3. Angular进入$digest loop。这个loop由一个处理$evalAsync queue 和处理$watch list两个更小的循环组成。$digest loop会在model稳定之前保持迭代，即$evalAsync queue为空，而且$watch list没有检测到任何变化。

					4. $evalAsync queue被用作安排必须跳出当前堆栈帧（堆栈帧指的是在堆栈中为当前正在运行的函数分配的区域（或空间）。传入的参数、返回地址（当这个函数结束后必须跳转到该返回地址。译注：即主调函数的断点处）以及函数所用的内部存储单元（即函数存储在堆栈上的局部变量）都在堆栈帧中。http://book.51cto.com/art/200804/70915.htm C.1.1  堆栈帧）之外，但在浏览器视图绘制之前的工作。这通常是通过使用setTimeout(0)来实现。但setTimeout(0)这方法，会导致缓慢，或者在每个事件处理完毕后，浏览器绘制视图时，出现视图闪烁（angular有没有去解决这个问题？如何解决？）。

					5. $watch list是有可能在最近一次迭代中被修改的表达式的集合。如果(model)发生了改变，那么$watch 函数会被调用，从而达到对特定的DOM重新赋值的目标。

					6. 一旦Angular $digest loop 完成了（之前3提到的情况），离开angular和javascript的context后，浏览器紧跟着就会去重绘DOM，以响应变化。

					下面解释例子“Hello Kitty”(-_-!)是如何在用户在文本框输入文本时实现数据绑定(data-binding)效果。

					1. 编译阶段(compilation phase)：

					a) ng-model和input directive在<input>中版定keydown事件监听器。

					b) {{name}}占位符（interpolation，不知道怎么翻译）（表达式）设置一个$watch以便在name发生改变时有所响应。

					2. 执行阶段(runtime phase)：

					a) 在inut控件中按下”X”按钮，让浏览器触发一个keydown事件；

					b) input directive捕捉到文本框值的改变，然后调用$apply(“name = ‘X’;”)，在angular execution context中更新应用的model。

					c) Angluar将 “name = ‘X’;”应用在model中。(model发生改变)

					d) $digest loop开始

					e) $watch list检测到name的值被改变了，然后再次解析{{name}}表达式，然后更新DOM。

					f) Angulart退出(angular) execution context，再依次退出keydown事件以及javascript execution context；

					g) 浏览器重绘视图，更新字符。

					<pre>
					<html lang="zh-cn" ng-app>
					<head>
					<meta charset="UTF-8">
					<title>Hello Kitty!</title>
					<style type="text/css">
					.ng-cloak {
					display: none;
					}
					</style>
					</head>
					<body>
					<input ng-model="name" class="ng-cloak"/>
					<p>Hello {{name}}!</p>
					<script src="../angular-1.0.1.js" type="text/javascript"></script>
					</body>
					</html>
					</pre>
					-->

				</section>

				<section class="future" style="display: none;">
					<h4>AngularJS Runtime -- To $apply, or Not to $apply?</h4>
					<!--
					
					angular JS之$apply()方法
					http://www.2cto.com/kf/201311/256848.html
					
					http://www.cnblogs.com/lcllao/archive/2012/09/23/2698651.html
二、scope的特性

scope提供$watch API（http://code.angularjs.org/1.0.2/docs/api/ng.$rootScope.Scope#$watch），用于监测model的变化。
scope提供$apply API（http://code.angularjs.org/1.0.2/docs/api/ng.$rootScope.Scope#$apply），在“Angular realm”（controller、server、angular event handler）之外，从系统到视图传播任何model的变化。
scope可以在提供到被共享的model属性的访问的时候，被嵌入到独立的应用组件中。scope通过（原型），从parent scope中继承属性。
scope在expression求值之时提供上下文环境。例如，{{username}}表达式是无意义的，除非它与一个特定的定义了”username”属性的scope一起进行求值。
					
					http://www.sitepoint.com/understanding-angulars-apply-digest/
					-->
					<!--
					To $apply, or Not to $apply?
					There is confusion amongst AngularJS developers about when $scope.$apply() should
					be called and when it shouldn’t. Recommendations and rumors on the Internet are
					rampant. This section will make it crystal clear.
					But first, let us try to put $apply in a simpler form.
					Scope.$apply is like a lazy worker. It is told to do a lot of work, and it is responsible for
					making sure that the bindings are updated and the view reflects all those changes. But
					rather than doing this work all the time, it does it only when it feels it has enough work
					to be done. In all other cases, it just nods, and notes the work for later. It only actually
					does the work when you get its attention and tell it explicitly to work. AngularJS does
					this internally at regular intervals within its lifecycle, but if the call comes from outside
					(say a jQuery UI event), scope.$apply just takes note, but does nothing. That is why
					we have to call scope.$apply to tell it, “Hey! You need to do this right now, and not
					wait!”
					Here are four quick tips about when (and how) to call $apply.

					• DO NOT call it all the time. Calling $apply when AngularJS is happily ticking away
					(in its $digest cycle, as we call it) will cause an exception. So “better safe than sorry”
					is not the approach you want to use.
					• DO CALL it when controls outside of AngularJS (DOM events, external callbacks
					such as jQuery UI controls, and so on) are calling AngularJS functions. At that
					point, you want to tell AngularJS to update itself (the models, the views, and so on),
					and $apply does just that.

					• Whenever possible, execute your code or function by passing it to $apply, rather
					than executing the function and then calling $apply(). For example, execute the
					following code:
					$scope.$apply(function() {
					$scope.variable1 = 'some value';
					executeSomeAction();
					});
					instead of the following:
					$scope.variable1 = 'some value';
					executeSomeAction();
					$scope.$apply();
					While both of these will have the same effect, they differ in one significant way.

					The first will capture any errors that happen when executeSomeAction is called, while
					the latter will quietly ignore any such errors. You will get error notifications from AngularJS
					only when you do the first.

					• Consider using something like safeApply:
					$scope.safeApply = function(fn) {
					var phase = this.$root.$$phase;
					if(phase == '$apply' || phase == '$digest') {
					if(fn && (typeof(fn) === 'function')) {
					fn();
					}
					} else {
					this.$apply(fn);
					}
					};
					You can monkey patch this into the topmost scope or the rootscope, and then use the
					$scope.$safeApply function everywhere. This has been under discussion, and hopefully
					in a future release, this will be the default behavior.

					-->
				</section>

				<section class="future" style="display: none;">
					<h4>Diving Deep with Dependency Injection</h4>
				</section>

				<section class="future" style="display: none;">
					<h4>Diving deep into the AngularUI Router</h4>
				</section>

				<section class="future" style="display: none;">
					<h4>Diving deep into the Angular Filter</h4>

					<!--
					创建AngularJS过滤器
					http://angularjs.cn/A00J
					-->

					<!--
					The Search Box
					filterService.searchText

					The Combo Boxes
					filterService.activeFilters.sports or city (depending on the box),

					The Check Box
					filterService.activeFilters.featured

					The Repeater
					"team in teamsList | filter:filterService.activeFilters | filter:filterService.searchText"

					-->

				</section>

				<section class="future" style="display: none;">
					<h4>The Teams List App: Filtering and Controller Communication</h4>

					<!--
					In this example, we tackle multiple things at the same time, but there are two major takeaways(经验教训):
					1. How do you use filters—especially in a clean, simple way—with repeaters?
					2. How do you communicate between controllers that do not share an inheritance relation?
					-->

					<!--
					Sharing Data between Controller
					https://github.com/tiw/angularjs-tutorial/blob/master/sharing-data-between-controllers.markdown
					-->

				</section>

				<section class="future" style="display: none;">
					<h4>Communicating Between Scopes with $on, $emit, and$broadcast</h4>
					<!--
					
					六、Scope Events Propagation（Scope事件传播）
					http://www.cnblogs.com/lcllao/archive/2012/09/23/2698651.html
					
					-->
					
					
					<!--
					在我们的link函数中，我们更新显示时间每秒一次，或者当用户改变指定绑定的时间格式字符串的时候。我们也要移除定时器，当指令被删除的时候，以避免引入内存泄露。
								element.on('$destroy', function() {
								$timeout.cancel(timeoutId);
								});
					这里有很多东西值得注意的，就像module.controller API, module.directive中函数参数是依赖注入，因此，我们可以在Link函数内部使用$timeout和dataFilter服务。
					我们注册了一个事件element.on('$destroy', ...), 是什么触发了这个$destory事件呢？
					AngularJS会触发一些特定的事件，当一个被angular编译过的DOM元素被移除的时候，它会触发一个$destory事件，同样的，当一个angular作用域被移除的时候，它会向下广播$destory事件到所有监听的作用域。
					通过监听事件，你可以移除可能引起内存泄露的事件监听器，注册在元素和作用域上的监听器在它们被移除的时候，会自动会清理掉，
					但是假如注册一个事件在服务或者没有被删除的DOM节点上，你就必须手工清理，否则会有内存泄露的风险。
					Best Practice:执行被移除的时候应该做一些清理的操作， 可以使用element.on('$destroy', ...)或者scope.on('$destroy', ...)来运行解除绑定的函数，
						
					-->
					

				</section>

				<section class="future" style="display: none;">
					<h4>$Watch , $location,$provide</h4>

					<!--
					http://angularjs.cn/A00M
					使用$location

					'$routeProvider', '$locationProvider',
					http://blog.fens.me/angularjs-url/

					历史管理 vs 网络爬虫SEO
					
					$location的双向绑定

					javascript MVC的最高境界就是单页面模式。
　　虽然时下的web应用是ajax的天下，但是如果我们想彻底的抛弃同步提交请求的想法真的应用到实践中，开发人员会发现它常常会变成一个吃力不讨好的事情，为什么说它是一件吃力不讨好的事情，我想主要体现在两个方面：
　　第一方面：ajax请求往往是作为纯数据的传输，那么页面效果的显示就需要开发人员自己操作DOM，使用各种javascript开发技巧，这就大大增加页面开发难度和复杂度，对于一个要投入市场的web应用，其成本和风险是可想而知的。
　　另一方面：同步提交页面会让用户享受一种很顶级的用户体验，这就是浏览器的前进和后退体验，如果让ajax做前进和后退，特别是用户和网站交互量很大的网站，这个操作可能会成为一件不可能完成的任务。
　　这里我首先讲如何解决前进和后退的问题，在浏览器的请求url地址有一个很重要的特性就是hash属性，例如我们写页面时候常常会写到这样的语句：
<a href=”#” onclick=”ftn()” id=”btn”>btn</a> 
　　当用户点击这个链接时候，会促发click事件，可能很多人没有留心到此时网页请求的url后面会添加一个#号，例如：www.cnblogs.com/#，如果我们把这个链接改下，如下：
<a href=”#sharpxiajun” onclick=”ftn()” id=”btn”>btn</a>
　　再点击这个链接，我们会发现链接变成了www.cnblogs.com/#sharpxiajun,前面的#sharpxiajun就是url的hash，url的hash是不会发送给服务端的，不过在浏览器里有专门的事件可以监听到它，这个事件就是hashchange事件，它是一个window的事件，浏览器的前进与后退支持url的hash改变，同时window可以监听到该事件，因此我们可以通过改变url的hash再加上ajax请求就可以模拟页面的同步提交了，同时该请求是可以使用浏览器的前进和后退操作。
					
					-->

					<!--
					构建自己的AngularJS，第一部分：Scope和Digest
					http://blog.const.net.cn/rss/read.php?id=7971
					-->
					
					
					<!--
					var myModule = angular.module('myModule', []);
					myModule.factory('serviceId', function() {
					var shinyNewServiceInstance;
					//factory function body that constructs shinyNewServiceInstance
					return shinyNewServiceInstance;
					});
					----------------------------------------------------------------------------------------------
					var myModule = angular.module('myModule', []).factory('serviceId', function() {
					var shinyNewServiceInstance;
					//factory function body that constructs shinyNewServiceInstance
					return shinyNewServiceInstance;
					});
					----------------------------------------------------------------------------------------------
					angular.module('myModule', [], function($provide) {
					$provide.factory('serviceId', function() {
					var shinyNewServiceInstance;
					//factory function body that constructs shinyNewServiceInstance
					return shinyNewServiceInstance;
					});
					});

					-->

				</section>

				<section class="future" style="display: none;">
					<h4>$resource, $http and promise</h4>

					
					<p>Promise</p>
					
					<!--
					Promises与Javascript异步编程
					http://www.uedsc.com/promises-javascript.html
					
					JavaScript Promise：去而复返
					http://segmentfault.com/blog/amio/1190000000363893?page=1
					
					Javascript异步编程的4种方法
					http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html
					
					//
					http://wiki.commonjs.org/wiki/Promises
					Promises/A by Kris Zyp — "Thenables"   
					Promises/B by Kris Kowal — Opaque Q API
					Promises/KISS by AJ ONeal
					Promises/C has been redacted
					Promises/D by Kris Kowal — "Promise-sendables", for interoperable instances of Promises/B.
					
					Javascript异步编程模型Promise模式详细介绍
					http://www.jb51.net/article/49898.htm
					
					JavaScript异步编程Promise模式的6个特性
					http://www.jb51.net/article/48680.htm
					
					//
					A+Promises -- by Forbes Lindesay			https://www.promisejs.org/
					JavaScript异步编程助手：Promise模式
					http://www.csdn.net/article/2013-08-12/2816527-JavaScript-Promise
					
					JavaScript Promises
					http://wildermuth.com/2013/8/3/JavaScript_Promises
					-->
					
					<!--
					Javascript中的异步编程规范Promises/A详细介绍
					http://www.jb51.net/article/50725.htm
					
					这篇文章主要介绍了Javascript中的异步编程规范Promises/A详细介绍,同时介绍了jQuery 中的 Deferred 和 Promises,需要的朋友可以参考下
					Javascript里异步编程逐渐被大家接受，先前大家一般通过回调嵌套，setTimeout、setInterval等方式实现，代码看起来非常不直观，不看整个代码逻辑很难快速理解。Javascript里异步函数大概有I/O函数（Ajax、postMessage、img load、script load等）、计时函数（setTimeout、setInterval）等。
这些我们都很熟悉，在复杂的应用中往往会嵌套多层，甚至以为某些步骤未完成而导致程序异常，最简单的例子：比如你往DOM中注入节点，你必须等待节点注入后在操作这个节点，当大量节点注入的时候，时间往往很难把握。如果我们得代码依赖第三方api的数据。我们无法获悉一个API响应的延迟时间，应用程序的其他部分可能会被阻塞，直到它返回结果。Promises对这个问题提供了一个更好的解决方案，它是非阻塞的，并且与代码完全解耦 。
那么，我看看Javascript里异步编程，首先推荐大家看看相对来说比较流行的Promises/A规范。
Promises/A规范
注：为了便于理解，描述可能和Promises/A规范有所出入；
CommonJS之Promises/A规范，通过规范API接口来简化异步编程，使我们的异步逻辑代码更易理解。
遵循Promises/A规范的实现我们称之为Promise对象，Promise对象有且仅有三种状态：unfulfilled（未完成）、fulfilled（已完成）、failed（失败/拒绝）；初始创建的时候是unfulfilled（未完成）状态，状态只可以从unfulfilled（未完成）变成fulfilled（已完成），或者unfulfilled（未完成）变成failed（失败/拒绝）。状态一旦变成fulfilled（已完成）或者failed（失败/拒绝），状态就不能再变了。
Promises/A规范提供了一个在程序中描述延时（或将来）概念的解决方案。主要的思想不是执行一个方法然后阻塞应用程序等待结果返回后再回调其他方法，而是返回一个Promise对象来满足未来监听。fulfilled状态和failed状态都可以被监听。Promise通过实现一个then接口来返回Promise对象来注册回调：
.then(fulfilledHandler, errorHandler, progressHandler)；
then接口用于监听一个Promise的不同状态。fulfilledHandler用于监听fulfilled（已完成）状态，errorHandler用于监听failed（失败/拒绝）状态，progressHandler用于监听unfulfilled（未完成）状态。Promise不强制实现unfulfilled（未完成）的事件监听（例如我们知道旧版本的jQuery（1.5，1.6）的Deferred就是一个Promise的实现，但没有实现对unfulfilled（未完成）状态的监听来回调progressHandler）。
一般认为，then接口返回的是一个新的Promise对象，而不是原来的Promise对象，这个新的新的Promise对象可以理解为是原来Promise对象的一个视图，它只包含原有Promise对象的一组方法，这些方法只能观察原有Promise对象的状态，而无法更改deferred对象的内在状态。这样可以避免多个调用者之间的冲突，多个调用者可以通过改变新的Promise对象状态而不影响别的调用者。
另外，Promise提供了resolve（实现状态由未完成到已完成）和reject（实现状态由未完成到拒绝或失败）两个接口实现状态的转变。
发一张图片帮助理解一下：
<img src="./img/promiseA.png" />

有了Promise，就可以以同步的思维去编写异步的逻辑了。在异步函数里，不能使用try/catch捕获异常，也不能抛出异常。有了Promise，我们可以直接显式定义errorHandler，相当于捕获异常。
以下是几个遵循Promises/A规范的类库，when，q，rsvp.js，jQuery.Deferred等等。
					
					-->
					
					
					<p>AngularJS中的promise</p>
					<!--
					$q -- AngularJS中的服务
					http://blog.csdn.net/renfufei/article/details/19174015
					
					AngularJS $q学习：轮询图表数据
					http://blog.csdn.net/salmonellavaccine/article/details/38741743
					
					
					卡通方式趣解AngularJS中的promise
					http://blog.jobbole.com/51178/
					http://www.lupaworld.com/article-233188-1.html
					http://www.lupaworld.com/article-233188-2.html
					
					
					你应该使用内建的$http方法而不是外部的XHR包装，它将返回一个$q promise， 执行这个promise的任何回调函数都会调用$rootScope.$apply()。 
					一些返回$q promise的模块将会隐式的调用$rootScope.$apply()。
					
					-->
					<p>$Http, ngResource--RESTful APIs</p>
					<!--
					
					angular $httpProvider配置
					http://blog.csdn.net/ristal/article/details/38539875
					http://my.oschina.net/buwei/blog/191640
					
					Make AngularJS $http service behave like jQuery.ajax()
					http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/
					
					
					说说Angular $http service中的缓存
					http://www.html-js.com/article/1828
					
					Power up Angular's $http service with caching
					http://blog.csdn.net/salmonellavaccine/article/details/38310657
					
					AngularJS的$resource
					http://blog.csdn.net/violet_day/article/details/17403207
					
					AngularJS $resource RESTful example
					http://blog.csdn.net/myweishanli/article/details/17952977
					
					AngularJS —— 使用 ngResource、RESTful APIs 和 Spring MVC 框架提交数据
					http://www.oschina.net/translate/post-data-ngresource-restful-apis-spring-mvc
					
					$http.get
					$http.head
					$http.post
					$http.put
					$http.delete
					$http.jsonp
					
					-->
					
					
					
					
					
					<!--
					$http with promise Working with Servers and Login
					-->

					<!--
					Additional $http functionality
					-->

				</section>

				<!--
				///////////////////////////////////////////// 艰难的决定 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part6</h1><h1>Time to say YES?</h1>
				</section>

				<!--
				///////////////////////////////////////////// 发现优点 /////////////////////////////////////////////
				-->
				<section class="future" style="display: none;">

					<section>
						<h1>Sounds Great!</h1>
						<ul>
							<li class="fragment">
								国际范儿——Internationalization
							</li>
							<li class="fragment">
								时尚百变——Bootstrap
							</li>
							<li class="fragment">
								紧跟潮流——不断更新扩大兼容Socket.IO
							</li>
							<li class="fragment">
								个性单纯——想测试，很Easy。。。
							</li>
							<li class="fragment">
								And so on ...
							</li>
						</ul>
					</section>

					<section>
						<h4>国际范Internationalization and Localization</h4>

						<!--
						什么是i18n和l10n?
						http://angularjs.cn/A00u
						-->

						<!--
						AngularJS supports i18n/L10n for the following filters out of the box:
						• currency
						• date/time
						• number
						There is also pluralization support (for English as well as i18n/L10n) with the ngPlur
						alize directive.
						All of this pluralization support is handled and managed by the $locale service, which
						manages the locale-specific rule sets. The $locale service works off of locale IDs, which
						generally consist of two parts: the country code and the language code. For example,
						en_US and en_UK, denote English used in the US and the UK, respectively. Specifying a
						country code is optional, just specifying “en” is a valid locale code.

						1,Index.html changes
						AngularJS requires you to have a separate index.html for each supported locale.
						Your server also needs to know which index.html it has to provide, depending on
						the user’s locale preferences (this could also be triggered from a client-side change,
						when the user changes his locale).

						2,Creating localized rule sets
						The next step is creating an angular.js file for each supported locale, like
						(angular_en-US.js and angular_zh-CN.js). This involves concatenating the
						localization rules for each particular language (the default files for the preceding
						two locales would be angular-locale_en-US.js and angular-locale_zh-CN.js) at the
						end of the angular.js or the angular.min.js file. So your angular_en-US.js would
						contain the contents of angular.js first, followed by the contents of the angularlocale_en-US.js.

						3,Sourcing the localized rule sets
						The final step involves ensuring that your localized index.html refers to the localized
						rule set instead of the original angular.js file. So index_en-US.html should use
						angular-en_US.js and not angular.js.

						NOTE :
						•Translation Length
						When internationalizing your apps, keep in mind that the lengths of your strings
						might change drastically from language to language. Design your CSS accordingly,
						and do thorough testing across the various languages. (Don’t forget that right to left
						languages also exist!  <a herf="http://www.ibm.com/developerworks/cn/web/1404_xiayin_bidihtml/index.html">Introduction to bidirectional languages</a>)
						•Timezones
						The AngularJS date/time filter picks up the timezone settings from the browser. So
						depending on the timezone of the computer, different people might see different
						information. Neither JS nor AngularJS have any built-in support to display time
						with a timezone specified by the developer

						-->

					</section>

					<section>
						<h4>配合度高How to implement a UT</h4>

						
						<!--
Unit and End to End Testing in AngularJS
						http://www.sitepoint.com/unit-and-e2e-testing-in-angularjs/
						http://www.sitepoint.com/unit-and-e2e-testing-in-angularjs/

						Unit testing is a technique that helps developers validate isolated pieces of code. End to end testing (E2E) comes into play when you want to ascertain that a set of components, when integrated together, work as expected. AngularJS, being a modern JavaScript MVC framework, offers full support for unit tests and E2E tests. Writing tests while developing Angular apps can save you great deal of time which you would have otherwise wasted fixing unexpected bugs. This tutorial will explain how to incorporate unit tests and E2E tests in an Angular application. The tutorial assumes that you are familiar with AngularJS development. You should also be comfortable with different components that make up an Angular application.
						We will use Jasmine as the testing framework and Karma as the test runner. You can use Yeoman to easily scaffold a project for you, or just quickly grab the angular seed app from GitHub.
						In case you don’t have a testing environment just follow these steps:
									Download and install Node.js, if you don’t already have it.
									Install Karma using npm (npm install -g karma).
									Download this tutorial’s demo app from GitHub and unzip it.
						Inside the unzipped app, you can find tests in the test/unit and test/e2e directories. To see the result of unit tests just run scripts/test.bat, which starts the Karma server. Our main HTML file is app/notes.html, and it can be accessed at http://localhost/angular-seed/app/notes.html.
						
Getting Started With Unit Tests

					Instead of just looking at how unit tests are written, let’s build a simple Angular app and see how unit test fits into the development process. So, let’s start with an application and simulataneously apply unit tests to the various components. In this section you will learn how to unit test:
								Controllers
								Directives
								Filters
								Factories
					We are going to build a very simple to-do note taking app. Our markup will contain a text field where the user can write a simple note. When a button is pressed, the note is added to the list of notes. We will use HTML5 local storage to store the notes. The initial HTML markup is shown below. Bootstrap is used to quickly build the layout.
									<html ng-app="todoApp">
									  <head>
										<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
										<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.2.2/angular.min.js" type="text/javascript"></script>
										<script src="//netdna.bootstrapcdn.com/bootstrap/3.0.3/js/bootstrap.min.js" type="text/javascript"></script>
										<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css" type="text/css"/>
										<script type="text/javascript" src="js/app.js"></script>
										<style>
										  .center-grey{
												 background:#f2f2f2;
												 margin-top:20;
										  }
										  .top-buffer {
												  margin-top:20px; 
										  }
										  button{
												  display: block; 
												  width: 100%;
										  }
										</style>
										<title>Angular Todo Note App</title>
									  </head>
									  <body>
										<div class="container center-grey" ng-controller="TodoController">
										  <div class="row top-buffer" >
											<span class="col-md-3"></span>
											<span class="col-md-5">
											  <input class="form-control" type="text" ng-model="note" placeholder="Add a note here"/> 
											</span>
											<span class="col-md-1">
											  <button ng-click="createNote()" class="btn btn-success">Add</button>
											</span>
											<span class="col-md-3"></span>
										  </div>
										  <div class="row top-buffer" >
											<span class="col-md-3"></span>
											<span class="col-md-6">
											  <ul class="list-group">
												<li ng-repeat="note in notes track by $index" class="list-group-item">
												  <span>{{note}}</span>
												</li>
											  </ul>
											</span>
											<span class="col-md-3"></span>
										  </div>
										</div>
									  </body>
									</html>
					As you can see in the above markup, our Angular module is todoApp and the controller is TodoController. The input text is bound to the note model. 
					There is also a list which shows all the note items that have been added. Furthermore, when the button is clicked, our TodoController‘s createNote() function runs. 
					Now let’s open up the included app.js file and create the module and controller. Add the following code to app.js.
									var todoApp = angular.module('todoApp',[]);
									todoApp.controller('TodoController', function($scope, notesFactory) {
									  $scope.notes = notesFactory.get();
									  $scope.createNote = function() {
										notesFactory.put($scope.note);
										$scope.note = '';
										$scope.notes = notesFactory.get();
									  }
									});
									 
									todoApp.factory('notesFactory', function() {
									  return {
										put: function(note) {
										  localStorage.setItem('todo' + (Object.keys(localStorage).length + 1), note);
										},
										get: function() {
										  var notes = [];
										  var keys = Object.keys(localStorage);
									 
										  for(var i = 0; i < keys.length; i++) {
											notes.push(localStorage.getItem(keys[i]));
										  }
									 
										  return notes;
										}
									  };
									}); 
						Our TodoController uses a factory called notesFactory to store and retrieve the notes. 
						When the createNote() function runs, it uses the factory to put a note into localStorage and then clears the note model. 
						So, if we were to unit test the TodoController we would need to ensure that when the controller is initialized, the scope contains a certain number of notes. 
						After running the scope’s createNote() function, the number of notes should be one more than the previous count. The code for our unit test is shown below.
												describe('TodoController Test', function() {
												  beforeEach(module('todoApp')); // will be run before each it() function
												 
												  // we don't need the real factory here. so, we will use a fake one.
												  var mockService = {
													notes: ['note1', 'note2'], //just two elements initially
													get: function() {
													  return this.notes;
													},
													put: function(content) {
													  this.notes.push(content);
													}
												  };
												 
												  // now the real thing: test spec
												  it('should return notes array with two elements initially and then add one',
													inject(function($rootScope, $controller) { //injects the dependencies
													  var scope = $rootScope.$new();
												 
													  // while creating the controller we have to inject the dependencies too.
													  var ctrl = $controller('TodoController', {$scope: scope, notesFactory:mockService});
												 
													  // the initial count should be two
													  expect(scope.notes.length).toBe(2);
												 
													  // enter a new note (Just like typing something into text box)
													  scope.note = 'test3';
												 
													  // now run the function that adds a new note (the result of hitting the button in HTML)
													  scope.createNote();
												 
													  // expect the count of notes to have been increased by one!
													  expect(scope.notes.length).toBe(3);
													})
												  );
												});
												
Explanation

							The describe() method defines the test suite. It just says which tests are included in the suite. Inside that we have a beforeEach() function that executes just before each it() function runs. The it() function is our test spec and has the actual test to be conducted. So, before each test is executed, we need to load our module.

							As this is a unit test, we don’t need external dependencies. You already know our controller depends on notesFactory for handling notes. So, to unit test the controller we need to use a mock factory or service. That’s why we have created mockService, which just simulates the real notesFactory and has the same functions, get() and put(). While our real factory uses localStorage to store notes, the fake one uses an underlying array.

							Now let’s examine the it() function which is used to carry out the test. You can see that it declares two dependencies $rootScope and $controller which are injected automatically by Angular. These two services are required for getting root scope for the app and creating controllers respectively.

							The $controller service requires two arguments. The first is the name of the controller to create. The second is an object respresenting the dependencies of the controller. The $rootScope.$new() returns a new child scope which is required by our controller. Notice we have also passed our fake factory implementation to the controller.

							Now, expect(scope.notes.length).toBe(2) asserts that when the controller is initialized scope.notes contains exactly two notes. If it has more or less than two notes, this test will fail. Similarly we populate the note model with a new item and run the createNote() function which is supposed to add a new note. Now expect(scope.notes.length).toBe(3) checks for this. Since in the beginning we initialized our array with two items, after running createNote() it should have one more (three items). You can see which tests failed/succeeded in Karma.

Testing the Factory

							Now we want to unit test the factory to ensure that it works as expected. The test case for notesFactory is shown below.
													
												describe('notesFactory tests', function() {
												  var factory;
												 
												  // excuted before each "it()" is run.
												  beforeEach(function() {
													// load the module
													module('todoApp');
												 
													// inject your factory for testing
													inject(function(notesFactory) {
													  factory = notesFactory;
													});
												 
													var store = {
													  todo1: 'test1',
													  todo2: 'test2',
													  todo3: 'test3'
													};
												 
													spyOn(localStorage, 'getItem').andCallFake(function(key) {
													  return store[key];
													});
												 
													spyOn(localStorage, 'setItem').andCallFake(function(key, value) {
													  return store[key] = value + '';
													});
												 
													spyOn(localStorage, 'clear').andCallFake(function() {
													  store = {};
													});
												 
													spyOn(Object, 'keys').andCallFake(function(value) {
													  var keys=[];
												 
													  for(var key in store) {
														keys.push(key);
													  }
												 
													  return keys;
													});
												  });
												 
												  // check to see if it has the expected function
												  it('should have a get function', function() {
													expect(angular.isFunction(factory.get)).toBe(true);
													expect(angular.isFunction(factory.put)).toBe(true);
												  });
												 
												  //check to see if it returns three notes initially
												  it('should return three todo notes initially', function() {
													var result = factory.get();
												 
													expect(result.length).toBe(3);
												  });
												 
												  //check if it successfully adds a new item
												  it('should return four todo notes after adding one more', function() {
													factory.put('Angular is awesome');
												 
													var result = factory.get();
													expect(result.length).toBe(4);
												  });
												});
						The test procedure is the same as for the TodoController except in few places. Remember, the actual factory uses localStorage to store and retrieve the note items. But, as we are unit testing we don’t want to depend on external services. So, we need to convert the function calls like localStorage.getItem() and localStorage.setItem() into fake ones to use our own store instead of using localStorage‘s underlying data store. spyOn(localStorage, 'setItem').andCallFake() does this. The first argument to spyOn() specifies the object of interest, and the second argument denotes the function on which we want to spy. andCallFake() gives us a way to write our own implementation of the function. So, in this test we have configured the localStorage functions to use our custom implementation. In our factory we also use the Object.keys() function for iteration and getting the total number of notes. So, in this simple case we can also spy on Object.keys(localStorage)to return keys from our own store, not local storage.

						Next, we check if the factory contains the required functions (get() and put()). This is done through angular.isFunction(). Then we check if the factory has three notes initially. In the last test we add a new note and assert that it increased the notes count by one.

Testing a Filter

						Now, say we need to modify the way notes are shown on the page. If a note’s text has more than 20 characters we should show only the first 10. 
						Let’s write a simple filter for this and name it truncate as shown below.
											todoApp.filter('truncate', function() {
											  return function(input,length) {
												return (input.length > length ? input.substring(0, length) : input );
											  };
											});
						In the markup, it can be used like this:
											{{note | truncate:20}}
						To unit test it, the following code can be used.
											describe('filter tests', function() {
											  beforeEach(module('todoApp'));
											  it('should truncate the input to 10 characters',
												//this is how we inject a filter by appending Filter to the end of the filter name
												inject(function(truncateFilter) {
												  expect(truncateFilter('abcdefghijkl', 10).length).toBe(10);
												})
											  );
											});
					The previous code is pretty straightforward. Just note that you inject a filter by appending Filter to the end of the actual filter name. Then you can call it as usual.

Testing a Directive

						Let’s just create a simple directive that gives a background color to the element it’s applied on. This can be done very easily with CSS. But, just to demonstrate the testing of directives let’s stick to the following:
						
											todoApp.directive('customColor', function() {
											  return {
												restrict: 'A',
												link: function(scope, elem, attrs) {
												  elem.css({'background-color': attrs.customColor});
												}
											  };
											});
						This can be applied to any element, e.g. <ul custom-color="rgb(128, 128, 128)"></ul>. The test code is shown below.
											describe('directive tests', function() {
												beforeEach(module('todoApp'));
											  it('should set background to rgb(128, 128, 128)',
												inject(function($compile,$rootScope) {
												  scope = $rootScope.$new();
											 
												  // get an element representation
												  elem = angular.element("<span custom-color=\"rgb(128, 128, 128)\">sample</span>");
											 
												  // create a new child scope
												  scope = $rootScope.$new();
											 
												  // finally compile the HTML
												  $compile(elem)(scope);
											 
												  // expect the background-color css property to be desirabe one
												  expect(elem.css("background-color")).toEqual('rgb(128, 128, 128)');
												 })
											  );
											});
						We need a service called $compile (injected by Angular) to actually compile and test the element on which a directive is applied. angular.element() creates a jqLite or jQuery (if available) element for us to use. Then, we compile it with a scope, and it’s ready to be tested. In this case we expect the background-color CSS property to be rgb(128, 128, 128). Refer to this doc to know which methods you can call on element.
						
Testing a Service
				测试服务 http://angularjs.cn/A00Q
						
						
E2E Tests With Angular
				
				端到端测试 http://angularjs.cn/A00E   -- Angular Scenario Runner
				
					In E2E tests we fit together a set of components and check whether the overall process works as expected. In our case we need to ensure that when a user enters something into the text field and clicks on the button it’s added to localStorage and appears in the list below the text field.

					This E2E test uses an Angular scenario runner. If you have downloaded the demo app and unzipped it, you can see that there is a runner.html inside test/e2e. This is our scenario runner file. The scenarios.js file contains the e2e tests (you will write the tests here). After writing the tests you can run http://localhost/angular-seed/test/e2e/runner.html to see the results. The E2E test to be added to scenarios.js is shown below.
												describe('my app', function() {
													  beforeEach(function() {
														browser().navigateTo('../../app/notes.html');
													  });
													 
													  var oldCount = -1;
													 
													  it("entering note and performing click", function() {
														element('ul').query(function($el, done) {
														  oldCount = $el.children().length;
														  done();
														});
													 
														input('note').enter('test data');
													 
														element('button').query(function($el, done) {
														  $el.click();
														  done();
														});
													  });
													 
													  it('should add one more element now', function() {
														expect(repeater('ul li').count()).toBe(oldCount + 1);
													  });        
													});
													
					Note: In the past, end to end testing could be done with a deprecated tool called Angular Scenario Runner . That tool is now in maintenance mode.
					Note: In the past, end to end testing could be done with a deprecated tool called Angular Scenario Runner . That tool is now in maintenance mode.
					
					
					Using Protractor : （https://github.com/angular/protractor） //http://localhost:8056/LearnHtml5forWebDev/angular_1.2.25/docs/guide/e2e-testing

						
Explanation

						As we are performing a complete test we should first navigate to our main HTML page, app/notes.html. This is achieved through browser.navigateTo(). The element.query() function selects the ul element to record how many note items are present initially. This value is stored in the oldCount variable. Next, we simulate entering a note into the text field through input('note').enter(). Just note that you need to pass the model name to the input() function. In our HTML page the input is bound to the ng-model note. So, that should be used to identify our input field. Then we perform a click on the button and check whether it added a new note (li element) to the list. We do this by comparing the new count (got by repeater('ul li').count()) with the old count.

Conclusion

						AngularJS is designed with solid JavaScript testing in mind, and favors Test Driven Development. So, always test your code while you are developing. This may seem time consuming, but it actually saves your time by eliminating most of the bugs that would appear later.

Additional Resources
						
						ngMock
						If your service/factory uses the http service to call a remote API you can return fake data from it for unit testing. Here is a guide for this （https://docs.angularjs.org/api/ngMock/service/$httpBackend）.
						
						Unit Testing  &&  E2E Testing
						This doc from the Angular website has some good information regarding unit testing. （https://docs.angularjs.org/guide/dev_guide.unit-testing）
						
						Angular testing framework : Protractor
						If you are starting a new Angular project consider using Protractor for E2E tests. （https://github.com/angular/protractor）
												
												
						
						-->
						
						
						
						<!--
						jasmine
						http://blog.fens.me/nodejs-jasmine-bdd/
						-->

						

						<!--Pagination Service with unit test-->

						<!--
						基于AngularJS的项目被预先配置为使用JsTestDriver来运行单元测试。
						你可以像下面这样运行测试：
						在一个单独的终端上，进入到angular-phonecat目录并且运行./scripts/test-server.sh来启动测试（Windows命令行下请输入.\scripts\test-server.bat来运行脚本，后面脚本命令运行方式类似）；
						打开一个新的浏览器窗口，并且转到http://localhost:9876 ；
						选择“Capture this browser in strict mode”。
						这个时候，你可以抛开你的窗口不管然后把这事忘了。JsTestDriver会自己把测试跑完并且把结果输出在你的终端里。
						运行./scripts/test.sh进行测试 。你应当看到类似于如下的结果：
						Chrome: Runner reset.
						Total 1 tests (Passed: 1; Fails: 0; Errors: 0) (2.00 ms)
						Chrome 19.0.1084.36 Mac OS: Run 1 tests (Passed: 1; Fails: 0; Errors 0) (2.00 ms)
						耶！测试通过了！或者没有... 注意：如果在你运行测试之后发生了错误，关闭浏览器然后回到终端关了脚本，然后在重新来一边上面的步骤。
						-->

					</section>

					<section>
						<h4>百变Using Bootstrap</h4>
						<!--
						http://blog.fens.me/bootstrap-angularjs-navbar/
						http://blog.fens.me/bootstrap-multilevel-navbar/
						-->
					</section>

					<section>
						<h4>紧跟潮流Using Socket.IO</h4>
					</section>

					<section>
						<h4>LOL, This feel bur shuang!</h4>
					</section>

				</section>
				<!--
				///////////////////////////////////////////// 注意事项 /////////////////////////////////////////////
				-->
				<section class="future" style="display: none;">
					<h1>Warnings!</h1>

					Some thing you should know before get married!
				</section>

				<section class="future" style="display: none;">
					<h4>代码美化与规范</h4>
					<!--
					Module的推荐设置
					http://www.cnblogs.com/lcllao/archive/2012/09/22/2698208.html
					
					Module的分离与合并？ controller的分离与合并
					-->

					<!--
					依赖$injection的顺序
					-->

					<!--
					隐式依赖注入
					AngularJS依赖注入系统的新特性使得AngularJS可以通过参数名称来判断依赖
					但是如你要压缩你的代码，你的变量名会被重命名，你就只能显示地指定依赖了。

					someModule.controller('MyController', function($scope, dep1, dep2) {
					...
					$scope.aMethod = function() {
					...
					}
					...
					});
					压缩之后若是修改了函数的参数名称会导致它不能注入依赖。那么可以改用 Array 的方式声明

					someModule.controller('MyController', ['$scope', 'dep1', 'dep2',
					function($scope,   dep1,   dep2) {
					...
					$scope.aMethod = function() {
					...
					}
					...
					}]);
					这样代码压缩就不会有问题了

					-->

					<!--
					现在我遇到这样一个问题，使用seajs配合angularjs，每个controller都写成了一个模块文件，再我最终部署的时候，我应该压缩合并这些controller了吗？
					seajs有相应的对angularjs的解决方案吗？ https://github.com/seajs/seajs/issues/555
					-->

					<!--
					How should I organize my modules?
					-->

					<!--
					Angular Namespace
					为了防止名称冲突，angular会在object的名称中加入前缀$。请不要在代码中使用$前缀以避免冲突。(-_-!! )
					-->

					<!--
					IE浏览器兼容性
					http://angularjs.cn/A00v

					IE处理非标准标签名会产生问题。问题可以分为两类，每类都有自己的解决方法。

					如果标签名是以my:前缀开始的: 这会被当成是一个XML的命名空间，并且必须使用`来声明。

					如果标签没有:符号，但它又不是一个标准的HTML标签。那么就必须预先使用document.createElement('my-tag')来创建它。

					如果你准备使用css选择器来对自定义标签添加样式，那么你就必须先用document.createElement('my-tag')来创建一下，不管有没有XML命名空间。

					好消息

					值得庆幸的是，IE的这种限制只存在在标签名上，标签属性名没有限制。所以，当在IE上使用<div my-tag your:tag> </div>.这样的形式时没有特殊要求。
					-->
					
					<p>框架对比</p>
					<!--
					Anatomy of a JavaScript MV* Framework -- Compare with  AngularJS, Backbone, and Ember 
					http://www.sitepoint.com/anatomy-javascript-mv-framework/
						- Routing
						- Data Binding
						- Templates/Views
						- Models
						- Data Access
						- Conclusion
					-->

					<!--
					WHAT IS THE RIGHT JAVASCRIPT FRAMEWORK FOR MY PROJECT?
					http://www.funnyant.com/javascript-framework-guide/
					
					-->
					<p>应用架构 / 项目实践</p>
					<!--
					BUILDING ANGULAR APPS USING FLUX ARCHITECTURE
					http://victorsavkin.com/post/99998937651/building-angular-apps-using-flux-architecture
					-->

					<!--
					https://thinkster.io/angulartutorial/mean-stack-tutorial/
					AngularJS Tutorial: Learn to Build Modern Web Apps with MEAN
					
					The acronym "MEAN" stands for "MongoDB Express.js AngularJS Node.js" and represents a group of technologies which are known to synergize well together.
					
					-->
					
					<p>代码组织</p>
					<!--
					
					如何组织大型JavaScript应用中的代码？
					http://kb.cnblogs.com/page/176541/
					//方式一
							controllers/
										LoginController.js
										RegistrationController.js
										ProductDetailController.js
										SearchResultsController.js
							directives.js
							filters.js
							models/
									CartModel.js
									ProductModel.js
									SearchResultsModel.js
									UserModel.js
							services/
									CartService.js
									UserService.js
									ProductService.js
					//方式二	
							cart/
									CartModel.js
									CartService.js
							common/
									directives.js
									filters.js
							product/
									search/
											SearchResultsController.js
											SearchResultsModel.js
									ProductDetailController.js
									ProductModel.js
									ProductService.js
							user/
									LoginController.js
									RegistrationController.js
									UserModel.js
									UserService.js
					//方式三
					http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html
						Root 
								default.html 
								styles 
									   app.css 
								partials 
									   home.html 
									   product.html 
									   store.html 
								scripts 
									   app.js 
									   controllers 
											   productCtrl.js 
											   storeCtrl.js 
									   directives 
											   gridDctv.js 
											   chartDctv.js 
									   filters 
											   formatFilter.js 
									   services 
											   dataSvc.js 
									   vendor 
											   angular.js 
											   angular.min.js

					-->
					
					<!-- 
					使用AngularJS构建大型Web应用
					http://www.infoq.com/cn/news/2013/02/angular-web-app/
					
					Building large apps with Angular.js
					http://www.pseudobry.com/building-large-apps-with-angular-js/
					
					Building Huuuuuge Apps with AngularJS
					http://briantford.com/blog/huuuuuge-angular-apps
					
					AngularJS+requireJS项目的目录结构设想
					http://www.cnblogs.com/jmtbai/p/3861897.html
					
					AngularJS 最佳实践
					http://www.lovelucy.info/angularjs-best-practices.html
					-->
					
					<p>注意 ： angularjs的“坑”</p>
					<!--
					用angularjs遇到的坑们
					http://www.cnblogs.com/zhrj000/p/3383898.html
					-->
					
					<p>Angular 与Require.js</p>
					<!--	
					RequireJS与AngularJS的集成
					http://segmentfault.com/blog/moejser/1190000000492238

					-->
					
					<p>Using jQuery</p>
					<!---
					与jquery类库的协作
					http://www.angularjs.cn/A0fG
					
					angularJS指令实战，制作一个可复用的幻灯组件(二) --- 怎样打包jQuery插件
					http://angularjs.cn/A0MO
					https://github.com/RenShine/ngSlide
					

					http://angularjs.cn/A0cj
					angularjs 与 jquerymobile兼容问题

					http://key232323.iteye.com/blog/1954904
					angularjs使用lhgdialog做对话框控件
					-->

				</section>

				<section class="future" style="display: block;">
					<br/>
					<br/>
					<br/>
					<br/>
					<h1>:D</h1>
					<h1>It's not a big deal ！</h1>
					<h1>we want the the honeymoon</h1>
				</section>

				<!--
				///////////////////////////////////////////// 未来 /////////////////////////////////////////////
				-->
				<section class="cover present" style="display: block;">
					<h1 style="color:red">Part7</h1><h1>Enjoy your life and Looking forward to the future</h1>
				</section>

				<section class="future" style="display: none;">
					<h4>总结</h4>
					<ul>
						<li>
							Angular 编程思想 http://www.oschina.net/translate/the-angular-way?print

							http://www.zhihu.com/question/21151483
							AngularJS 胜在可用和易于测试这两方面。
							
							例如：
									使用双大括号{{}}语法进行数据绑定；
									使用DOM控制结构来实现迭代或者隐藏DOM片段；
							好处：
									能将逻辑代码关联到相关的DOM元素上；
									能将HTML分组成可重用的组件。
					<!--
					端对端的解决方案
	  AngularJS试图成为WEB应用中的一种端对端的解决方案。这意味着它不只是你的WEB应用中的一个小部分，而是一个完整的端对端的解决方案。
	  这会让AngularJS在构建一个CRUD（增加Create、查询Retrieve、更新Update、删除Delete）的应用时显得很“固执”（原文为 opinionated,意指没有太多的其他方式）。
	  但是，尽管它很“固执”，它仍然能确保它的“固执”只是在你构建应用的起点，并且你仍能灵活变动。AngularJS的一些出众之处如下：
	  构建一个CRUD应用可能用到的全部内容包括：数据绑定、基本模板标识符、表单验证、路由、深度链接、组件重用、依赖注入。
	  测试方面包括：单元测试、端对端测试、模拟和自动化测试框架。
	  具有目录布局和测试脚本的种子应用作为起点。
					AngularJS的可爱之处 
		AngularJS通过为开发者呈现一个更高层次的抽象来简化应用的开发。
		如同其他的抽象技术一样，这也会损失一部分灵活性。换句话说，并不是所有的应用都适合用AngularJS来做。
		AngularJS主要考虑的是构建CRUD应用。幸运的是，至少90%的WEB应用都是CRUD应用。
		但是要了解什么适合用AngularJS构建，就得了解什么不适合用AngularJS构建。
		如游戏，图形界面编辑器，这种DOM操作很频繁也很复杂的应用，和CRUD应用就有很大的不同，它们不适合用AngularJS来构建。
		像这种情况用一些更轻量、简单的技术如jQuery可能会更好。
					
					-->
							<!--
							debug 麻烦
							AngularJS 给出的调用链又深、又难理解。

							另外还有两个可以注意的旧版本问题，最近新版本已经解决（还没发布到 bower）：
							- $resource 对 promise 的支持；$resource 功能稍弱.缺少很多必要的 HTTP 方法，需要自定义；缺少全局配置；内部 $http 的 PATCH 方法对低版 IE 不兼容；
							- directive 对动画的支持；
							-->
						</li>
					</ul>

				</section>

				<section class="future" style="display: none;">
					<h4>TODO 击鼓传花 -- 未接之谜</h4>
					<ul>
						<li>
							<span>AngularJs 日志输出</span>
							<span>如何对Directive/Service做单元测试？</span>
							<span>如何对AngularJs做测试？</span>
						</li>
						<li>
							<span>AngularJ项目代码的组织</span><!--AngularJS从构建项目开始 http://blog.fens.me/angularjs-yeoman-project/-->
							<span>如何实现工程化？</span>
						</li>
					</ul>

					<!--
					http://angularjs.cn/A08H
					ng-include 怎么加loading
					src="r_tpl" 改变回去后台去模版文件 这取模版过程有一段时间，我应该怎么在中间加一个loading
					-->

				</section>

				<!--
				///////////////////////////////////////////// 结束 /////////////////////////////////////////////
				-->
				<section class="future" style="display: none;">
					<h1>THE END</h1>
					<br/>
					<br/>
					<br/>
					<h3 class="fragment">Angular & U</h3>
					<h3 class="fragment">Bring together by Kenny</h3>
					<h3 class="fragment">have a happy time later on ...</h3>
				</section>
				<section class="future" style="display: none;">
					<h2>Thanks</h2>
					<ol>
						<li>
							<a href="http://www.cnblogs.com/lcllao/archive/2012/10/18/2728787.html">
								AngularJs学习笔记--Guide教程系列文章索引
							</a>
						</li>
						<li>
							<a href="http://www.ng-newsletter.com/">
								ng-newsletter
							</a>
						</li>
						<li>
							<a href="http://angularjs.cn/T001">
								AngularJs中文社区
							</a>
						</li>
						<li>
							<a href="http://woxx.sinaapp.com/">
								用AngularJS开发下一代Web应用
							</a>
						</li>

					</ol>
				</section>

				<section class="future" style="display: none;">
					<h1>Q &amp; A</h1>
				</section>

				<!--<section class="future" style="display: none;">
				<svg width="800px" height="600px">
				<path id="my_path" d="M 20,260 C 40,180 80,180 100,260"  />
				<text>
				<textPath xlink:href="#my_path">如何实现工程化？</textPath>
				</text>
				</svg>
				</section>-->

			</div>
			<div class="progress" style="display: block;">
				<span style="width: 0px;"></span>
			</div>
			<aside class="controls" style="display: block;">
				<div class="left"></div>
				<div class="right enabled"></div>
				<div class="up"></div>
				<div class="down"></div>
			</aside>
			<aside id="coverbox" style="display: block;">
				<div class="clock" id="clock">
					<div class="clock-xin"></div>
					<div class="clock-xin2"></div>
					<div id="date" class="date"></div>
					<!--
					<div id="hour" class="hour"></div>
					<div id="min" class="min"></div>
					-->
					<div id="sec" class="sec"></div>
				</div>
				<div id="mincounter">
					0 Mins
				</div>
			</aside>
			<aside id="btn_viewdemo">
				View full demo
			</aside>
		</div>

		<script type="text/javascript" src="js/head.js"></script>
		<script type="text/javascript" src="js/reveal.min.js"></script>
		<script type="text/javascript">
			var pageIndex = {h:0,v:0};
			// Full list of configuration options available here: https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls : true,
				progress : true,
				history : true,
				mouseWheel : false,
				overview : true,
				keyboard : true,
				rollingLinks : true,
				slideNumber : true,
				theme : Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition : Reveal.getQueryHash().transition || 'linear', // default/cube/page/concave/zoom/linear/none

				// Optional libraries used to extend on reveal.js
				dependencies : [{
					src : 'js/plugin/classList.js',
					condition : function() {
						return !document.body.classList;
					}
				}, {
					src : 'js/plugin/showdown.js',
					condition : function() {
						return !!document.querySelector('[data-markdown]');
					}
				}, {
					src : 'js/plugin/markdown.js',
					condition : function() {
						return !!document.querySelector('[data-markdown]');
					}
				}, {
					src : 'js/plugin/zoom.js',
					async : true,
					condition : function() {
						return !!document.body.classList;
					}
				}, {
					src : 'js/plugin/notes.js',
					async : true,
					condition : function() {
						return !!document.body.classList;
					}
				}]
			});
			
			Reveal.addEventListener( 'ready', function( event ) {
			});
			Reveal.addEventListener( 'slidechanged', function( event ) {
				pageIndex.h = event.indexh;
				pageIndex.v = event.indexv;
			});
		</script>
		<script type="text/javascript" src="js/plugin/zoom.js"></script>
		<script type="text/javascript" src="js/plugin/notes.js"></script>

		<!--Refer to angular 1.2.24-->
		<script type="text/javascript" src="./angularjs/angular.min.js"></script>
		<script type="text/javascript">
			var app = angular.module("angularDemoModule", []);
		</script>
		<script type="text/javascript" src="./angularjs/controller/myTipsCtr.js"></script>
		<script type="text/javascript" src="./angularjs/controller/helloCtr.js"></script>
		<script type="text/javascript" src="./angularjs/controller/myBoxCtr.js"></script>

		<script type="text/javascript" src="js/viewdemocode.js"></script>
		
		<script type="text/javascript" src="js/clock.js"></script>
		
		<!--
		TODO : ng-click="showPic(startUp)";
		<div class="img_popup"> <img src="./img/startup.png"/> </div>
		-->

	</body>
</html>