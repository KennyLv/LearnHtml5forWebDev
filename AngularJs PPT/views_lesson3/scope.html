<h1>AngularJS  的 -- <span style="color:red;">运行原理</span> </h1><!----><section  ng-show="currentShow == '0'"><h4>Scope  -- AngularJS's Memory</h4>提到过，scope是被放置于一个类似应用的DOM结构的层次结构中。<br/>而在<a href="#/10/1">AngualrJs的解析</a>中也提到，每一个Directive都能对DOM注册监听事件。正是scope负责检测model的变化，为表达式的执行提供execution context，传播事件。<br/><p>scope的特性</p><ul>		<li>scope提供$watch API，用于监测model的变化。</li>		<li>scope提供$apply API，在 controller、server、angular event handler 之外，从系统到视图传播任何model的变化。</li>		<li>scope可以在通过原型，从parent scope中继承属性。</li>		<li>scope在expression求值之时提供上下文环境。例如，{{username}}表达式是无意义的，除非它与一个特定的定义了”username”属性的scope一起进行求值。</li></ul>		<p>scope层次结构</p><!--JavaScript 的原型链继承http://www.lovelucy.info/understanding-scopes-in-angularjs.html--><ul><li>每一个angular应用有且只有一个root scope，但可以拥有多个child scope，因为一些directive会创建新的child scope。附加到的DOM的root scope的位置是通过ng-app directive的位置定义的。</li><li>当新的scope被创建后，他们将作为一个child scope，加入到parent scope中。这样，创建了一个与它们附属的DOM相似的树结构。</li><li>当angular对{{username}}求值时，它首先查看与当前元素关联的scope的username属性。如果没有找到对应的属性，它将会一直向上搜索parent scope，直到到达root scope。</li></ul>用参数数组的方式添加了$scope的引用，在AngularJs中我们称为“依赖注入”，而AngularJs实现依赖注入的方式也是通过$Injector这个服务实现的。<span class="fragment" >1，所有的AngularJs服务都是实现为单例模式，并注册在依赖注入系统中。<br/>2，当AngularJs启动时，Controller开始启动构造的时候，通过参数指出依赖。<br/>3，AngularJS的依赖注入系统帮你查找左右依赖，负责实例化，并且按照工场函数要求的样子传递依赖。<br/></span>			</section><section  ng-show="currentShow == '1'">	<h3>scope.$watch</h3>	<!--	http://www.html-js.com/article/With-the-development-of-Angular-web-applications-in-AngularJS-watch	-->	在使用AngulaJS编写应用时，我们经常需要做的一件事情就是对模型中的变量进行监视，并对其发生的变化做出相应的回应。	AngularJS为我们提供了一个非常方便的$watch方法，它可以帮助我们在每个scope中监视其中的变量。下面是一个非常简单的例子：		<div ng-app='watch'>    <input ng-model='name' type='text'/>    <div>change count: {{count}}</div>	</div>	<script>			angular.module('watch',[])			.run(['$rootScope',function($rootScope){				$rootScope.count = 0;				$rootScope.name = 'Alfred';				$rootScope.$watch('name',function(){					$rootScope.count++;				})			}]);	</script>	上面的这段代码非常简单，它用$watch来对$rootScope中的name进行监视，并在它发生变化的时候将$rootScope中的count属性增加1。	因此，每当我们对name进行一次修改时，下面显示的change count数字就会增加1。在AngularJS内部，每当我们对ng-model绑定的name属性进行一次修改，AngularJS内部的$digest就会运行一次，并在运行结束之后检查我们使用$watch来监视的东西，如果和进行上一次$digest之前相比有了变化，则执行我们在其中绑定的处理函数。然而，我们在实际运用中常常不只是对一个原始类型的属性进行监视，如果你还记得Javascript中的六种基本类型，你一定会记得原始类型（数字，字符串）和引用类型的区别。对于原始类型，如果我们使用了一个赋值操作，则这个原始类型变量会“真正的”被进行一次复制(ng-copy)，然而对于引用类型，在进行赋值时，仅仅时将赋值的变量指向了这个引用类型。在AngularJS的$watch方法中，对两者的操作也有不同之处。原始类型，就像我们上面例子中提到的$rootScope，没有什么特别之处，然而如果要对一个引用类型，尤其是在实际运用中常见的对象数组进行监视时，情况就不一样了。我们来看下面的例子：<div ng-app='watch'><div hg-repeat='item in items'>	<input ng-model='item.a'/><span>{{item.a}}</span></div><div>change count: {{count}}</div></div><pre>angular.module('watchTestApp', []).controller('testCtrl', ['$scope',function($scope) {		$scope.count = 0;		$scope.items = [			{ "a": 1 },			{ "a": 2 },			{ "a": 3 },			{ "a": 4 }		]		$scope.$watch('items',function(){			$scope.count++;		});}]);</pre>如果我们对四个input中的a进行改变时，我们会发现，count的值依然是0。这是怎么回事？难道没有$watch失灵了吗？正如我们前面所说的，$watch在对待原始类型和引用类型会有不同的处理方式，这就要首先说一说$watch函数的第三个参数。在前面的例子中，我们知道，$watch函数有接收两个参数，第一个参数是需要监视的对象，第二个参数是在监视对象发生变化时需要调用的函数，实际上$watch还有第三个参数，它在默认情况下是false。在默认情况下，即不显式指明第三个参数或者将其指明为false时，我们进行的监视叫做“引用监视”。引用监视的原词的“reference watch”，它的意思是只要监视的对象引用没有发生变化，就不算它发生了变化。具体来说，在上面的例子中，只要是items的引用没有发生变化，就算items中的一些属性发生了变化，$watch也会当做没有看见。相反，如果我们将$watch的第三个变量设置为true，那么此时我们进行的监视叫做“全等监视”，原词是“equality watch”。<pre>		$scope.$watch('items',function(){			$scope.count++;		},true);</pre>那么在什么时候算是引用发生了变化呢？比如说将一个新的数组newItems赋值给items，此时$watch才会站出来说：“你变了！你再也不是以前我认识的那个和我一起看星星看月亮聊人生理想并且教会我什么叫做爱的人了！”因此，有同学就会问了，既然全等监视这么好，那么我们为什么不直接用全等监视呢？当然，任何事情都有好的坏的两个方面，全等监视固然是好，但是它在运行时需要先遍历整个监视对象，然后在每次$digest之前使用angular.copy()将整个对象深拷贝一遍然后在运行之后用angular.equal()将前后的对象进行对比，上面的例子中因为items比较简单，因此可能性能上不会有什么差别，但是到了实际生产时，我们要面对的数据千千万万，可能因为全等监视这一个设置就会消耗大量的资源，让应用停滞不前。因此这就需要我们在使用时进行权衡，究竟应该使用哪一种监视方式。除了上面提到的两种方式之外，在angular 1.1.4版本之后，添加了一个$watchCollection()方法来针对数组（也就是集合）进行监视，它的性能介于全等监视和引用监视二者之间，即它并不会对数组中每一项的属性进行监视，但是可以对数组的项目的增减做出反应。比如还是上面的例子：$rootScope.items = [		{ "a": 1 },		{ "a": 2 },		{ "a": 3 },		{ "a": 4 }		]		$rootScope.$watchCollection('items',function(){			$rootScope.count++;		}) }]); 如果改变了items[0]的a属性值，$watch并不会做出反应，但是如果我们在items上push或者pop了一个项目，$watch就会开始行动了。		</section><section  ng-show="currentShow == '2'">		<h3>scope.$apply</h3>		http://jimhoskins.com/2012/12/17/angularjs-and-apply.html		http://www.2cto.com/kf/201311/256848.html		http://www.lovelucy.info/understanding-scopes-in-angularjs.html											<br/><br/><br/><br/></section>