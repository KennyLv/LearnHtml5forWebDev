<h1>AngularJS  的 -- <span style="color:red;">运行原理</span> </h1><!--AngularJS and scope.$applyhttp://jimhoskins.com/2012/12/17/angularjs-and-apply.htmlhttp://www.html-js.com/article/With-the-development-of-Angular-web-applications-in-AngularJS-watchhttp://www.2cto.com/kf/201311/256848.htmlhttp://www.lovelucy.info/understanding-scopes-in-angularjs.htmlhttp://www.sitepoint.com/understanding-angulars-apply-digest/	--><section  ng-show="currentShow == '0'"><p>在AngualrJs的运行分析中，我们数次提到了Scope，它是AngularJs双向绑定运行的核型所在：</p><ul><li>每一个Directive都能对DOM注册监听事件，Scope是View向AngularJs发送事件的纽带。</li><li>Scope是指挥model到view更新的驱动力。</li></ul><h3>Scope</h3><p>scope是被放置于一个类似应用的DOM结构的层次结构中，负责检测model的变化，为表达式的执行提供execution context，传播事件。</p><p><strong>scope的特性</strong></p><ul>		<li>scope提供$apply API，在 controller、server、angular event handler 之外，从系统到视图传播任何model的变化。</li>		<li>scope提供$watch API，用于监测model的变化。</li>		<li>scope可以在通过原型，从parent scope中继承属性。</li>		<li>scope在expression求值之时提供上下文环境。例如，{{username}}表达式是无意义的，除非它与一个特定的定义了”username”属性的scope一起进行求值。</li></ul>	<p><strong>scope层次结构</strong></p><ul>	<li>每一个angular应用有且只有一个root scope，但可以拥有多个child scope，因为一些directive会创建新的child scope。附加到的DOM的root scope的位置是通过ng-app directive的位置定义的。</li>	<li>当新的scope被创建后，他们将作为一个child scope，加入到parent scope中。这样，创建了一个与它们附属的DOM相似的树结构。</li>	<li>当angular对{{username}}求值时，它首先查看与当前元素关联的scope的username属性。如果没有找到对应的属性，它将会一直向上搜索parent scope，直到到达root scope。</li></ul><p>PS : 参考<a href=" http://www.lovelucy.info/understanding-scopes-in-angularjs.html" target="_blank">JavaScript 的原型链继承</a></p><h3>监视Model变化 -- scope.$watch</h3><p>在使用AngulaJS编写应用时，我们经常需要做的一件事情就是对模型中的变量进行监视，并对其发生的变化做出相应的回应。AngularJS为我们提供了一个非常方便的$watch方法，它可以帮助我们在每个scope中监视其中的变量。</p><p>下面是一个非常简单的例子：</p>	<pre>	&lt;div ng-app='watch'&gt;    &lt;input ng-model='name' type='text'/&gt;    &lt;div&gt;change count: {{count}}&lt;/div&gt;	&lt;/div&gt;	...	angular.module('watchTestApp', []).controller('testCtrl', ['$scope',function($scope) {			$scope.count = 0;			$scope.name = 'Alfred';			$scope.$watch('name',function(){				$scope.count++;			})	}]);</pre>		<p>	上面的这段代码非常简单，它用$watch来对$rootScope中的name进行监视，并在它发生变化的时候将$rootScope中的count属性增加1。	因此，每当我们对name进行一次修改时，下面显示的change count数字就会增加1。</p><p>在AngularJS内部，每当我们对ng-model绑定的name属性进行一次修改，AngularJS内部的$digest loop就会运行一次，并在运行结束之后检查我们使用$watch来监视的东西，如果和进行上一次$digest之前相比有了变化，则执行我们在其中绑定的处理函数。</p><p>然而，我们在实际运用中常常不只是对一个原始类型的属性进行监视，如果你还记得Javascript中的六种基本类型，你一定会记得原始类型（数字，字符串）和引用类型的区别。对于原始类型，如果我们使用了一个赋值操作，则这个原始类型变量会“真正的”被进行一次复制(ng-copy)，然而对于引用类型，在进行赋值时，仅仅时将赋值的变量指向了这个引用类型。在AngularJS的$watch方法中，对两者的操作也有不同之处。原始类型，就像我们上面例子中提到的$rootScope，没有什么特别之处，然而如果要对一个引用类型，尤其是在实际运用中常见的对象数组进行监视时，情况就不一样了。我们来看下面的例子：</p><pre>&lt;div ng-app='watch'&gt;&lt;div hg-repeat='item in items'&gt;	&lt;input ng-model='item.a'/&gt;&lt;span&gt;{{item.a}}&lt;/span&gt;&lt;/div&gt;&lt;div&gt;change count: {{count}}&lt;/div&gt;&lt;/div&gt;</pre><pre>angular.module('watchTestApp', []).controller('testCtrl', ['$scope',function($scope) {		$scope.count = 0;		$scope.items = [			{ "a": 1 },			{ "a": 2 },			{ "a": 3 },			{ "a": 4 }		]		$scope.$watch('items',function(){			$scope.count++;		});}]);</pre><p>如果我们对四个input中的a进行改变时，我们会发现，count的值依然是0。这是怎么回事？难道没有$watch失灵了吗？</p><p>正如我们前面所说的，$watch在对待原始类型和引用类型会有不同的处理方式，这就要首先说一说$watch函数的第三个参数。在前面的例子中，我们知道，$watch函数有接收两个参数，第一个参数是需要监视的对象，第二个参数是在监视对象发生变化时需要调用的函数，实际上$watch还有第三个参数，它在默认情况下是false。在默认情况下，即不显式指明第三个参数或者将其指明为false时，我们进行的监视叫做“引用监视”。引用监视的原词的“reference watch”，它的意思是只要监视的对象引用没有发生变化，就不算它发生了变化。</p><p>具体来说，在上面的例子中，只要是items的引用没有发生变化，就算items中的一些属性发生了变化，$watch也会当做没有看见。相反，如果我们将$watch的第三个变量设置为true，那么此时我们进行的监视叫做“全等监视”，原词是“equality watch”。</p><pre>		$scope.$watch('items',function(){			$scope.count++;		},true);</pre><p>那么在什么时候算是引用发生了变化呢？比如说将一个新的数组newItems赋值给items，此时$watch才会站出来说：“你变了！你再也不是以前我认识的那个和我一起看星星看月亮聊人生理想并且教会我什么叫做爱的人了！”</p><p>因此，有同学就会问了，既然全等监视这么好，那么我们为什么不直接用全等监视呢？当然，任何事情都有好的坏的两个方面，全等监视固然是好，但是它在运行时需要先遍历整个监视对象，然后在每次$digest之前使用angular.copy()将整个对象深拷贝一遍然后在运行之后用angular.equal()将前后的对象进行对比，上面的例子中因为items比较简单，因此可能性能上不会有什么差别，但是到了实际生产时，我们要面对的数据千千万万，可能因为全等监视这一个设置就会消耗大量的资源，让应用停滞不前。因此这就需要我们在使用时进行权衡，究竟应该使用哪一种监视方式。</p><p>除了上面提到的两种方式之外，在angular 1.1.4版本之后，添加了一个$watchCollection()方法来针对数组（也就是集合）进行监视，它的性能介于全等监视和引用监视二者之间，即它并不会对数组中每一项的属性进行监视，但是可以对数组的项目的增减做出反应。</p><p>比如还是上面的例子：</p><pre>$rootScope.items = [		{ "a": 1 },		{ "a": 2 },		{ "a": 3 },		{ "a": 4 }		]		$rootScope.$watchCollection('items',function(){			$rootScope.count++;		}) }]);</pre><p> 如果改变了items[0]的a属性值，$watch并不会做出反应，但是如果我们在items上push或者pop了一个项目，$watch就会开始行动了。	</p>			<h3>响应View变更 -- scope.$apply</h3>	<p>我们看到$watch的函数的第二个参数是一个回调函数，问题是Angular怎么知道啥时候去调用它呢？ 	但是现在又没有一种方法直接去通知说某个对象上的数据变了，而目前比较主流的策略有以下有两种解决方案：</p>	<ul>			<li>			一种是需要用特殊的对象，让所有的数据都只能通过调用对象的方法设置，而不是直接通过property指定。			这样的话，所有的修改就可以被记录下来了，就知道什么时候页面需要更新了。这样做的弊端就是我们必须去继承一个特殊的对象。对于赋值也只能通过object.set('key', 'value')而不是object.key=value的方式。			</li>			<li>				另一种就是angular JS采用的方式，在每一次Javascript代码执行序列执行结束后都去检查是否有数据的改变。			</li>	</ul>		<p>假定你在一个ng-click 的事件中改变了某个scope model，这个时候 AngularJS会自动通过调用$digest()函数来触发$digest loop。</p>	<p>$digest loop依次调用watcher列表中的$watch，每个$watch()都会去check当前绑定的scope的值是否与上次计算结果一致。如果不是，相应的listener会被触发。</p>		<!--				在框架中，像EmberJS和KnockoutJS就是这么干的（虽然我都没接触过——囧）。		这看起来似乎并不高效，甚至严重影响性能。但是angular JS采用了一些比较巧妙的手段解决了这个问题（还没研究过，目前尚不明确）。	这么做的好处就是，我们可以随便使用任意对象，对于赋值方式也没有限制，而且对于数据的改变也能觉察到。     对于angular JS采取的这种解决方案，我们关心的是什么时候数据发生了变化，而这也正是$scope.$apply()派上用场的地方。	 对于检查绑定的数据到底有没有发生变化，实际上是由$scope.$digest()完成的，	 但是我们几乎从来就没有直接调用过这个方法，而是调用$scope.$apply()方法，是因为在$scope.$apply()方法里面，它会去调用$scope.$digest()方法。	 	 $scope.$apply()方法带一个函数或者一个表达式，然后执行它，最后调用$scope.$digest()方法去更新bindings或者watchers。	 	 The second argument passed to $watch() is known as a listener function, and is called whenever the value of aModel changes. It is easy for us to grasp that when the value of aModel changes this listener is called, updating the expression in HTML. But, there is still one big question! How does Angular figure out when to call this listener function? In other words, how does AngularJS know when aModel changes so it can call the corresponding listener? Does it run a function periodically to check whether the value of the scope model has changed? Well, this is where the $digest cycle steps in.	 	 It’s the $digest cycle where the watchers are fired. When a watcher is fired, AngularJS evaluates the scope model, and if it has changed then the corresponding listener function is called. So, our next question is when and how this $digest cycle starts.	 	 The $digest cycle starts as a result of a call to $scope.$digest(). Assume that you change a scope model in a handler function through the ng-click directive. In that case AngularJS automatically triggers a $digest cycle by calling $digest(). When the $digest cycle starts, it fires each of the watchers. These watchers check if the current value of the scope model is different from last calculated value. If yes, then the corresponding listener function executes. As a result if you have any expressions in the view they will be updated. In addition to ng-click, there are several other built-in directives/services that let you change models (e.g. ng-model, $timeout, etc) and automatically trigger a $digest cycle.	 	 So far, so good! But, there is a small gotcha. In the above cases, Angular doesn’t directly call $digest(). Instead, it calls $scope.$apply(), which in turn calls $rootScope.$digest(). As a result of this, a digest cycle starts at the $rootScope, and subsequently visits all the child scopes calling the watchers along the way.	 	 Now, let’s assume you attach an ng-click directive to a button and pass a function name to it. When the button is clicked, AngularJS wraps the function call within $scope.$apply(). So, your function executes as usual, change models (if any), and a $digest cycle starts to ensure your changes are reflected in the view.	 	 Note: $scope.$apply() automatically calls $rootScope.$digest(). The $apply() function comes in two flavors. The first one takes a function as an argument, evaluates it, and triggers a $digest cycle. The second version does not take any arguments and just starts a $digest cycle when called. We will see why the former one is the preferred approach shortly.	 	 -->	 <br/><br/><br/></section>