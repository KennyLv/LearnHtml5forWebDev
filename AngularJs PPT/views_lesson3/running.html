<h1>AngularJS  的 -- <span style="color:red;">运行原理</span> </h1><!--http://www.sitepoint.com/anatomy-javascript-mv-framework/http://www.sitepoint.com/understanding-angulars-apply-digest/http://jasonmore.net/angular-js-directives-difference-controller-link/http://segmentfault.com/q/1010000000664866http://www.ifeenan.com/angularjs/2014-09-04-%5B%E8%AF%91%5DNG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/http://www.html-js.com/article/2000http://www.adobe.com/cn/devnet/html5/articles/angularjs-directives-and-the-computer-science-of-javascript.html--><section  ng-show="currentShow == '0'">	<p><strong>Angular模版的不同之处，在于它是基于DOM的而不是基于字符串的。</strong></p>	<p>视图与数据的绑定对我们来说是透明的。 开发者无须为更新视图、model做任何动作。</p>	</section>	<section  ng-show="currentShow == '1'">	<img src="./img/view.png" style="height:200px;margin-left:200px;"/><br/>						AngularJs页面的编译分为三个阶段：<br/>			1，AngularJs编译器遍历DOM查找HTML中的directives，并会按照优先级排序加入一个指令列表中，并且他们的compile方法会被调用。			directives的$compile()函数能修改DOM结构，并且要负责生成一个链接函数<br/>			2，通过调用一步所说的链接函数来将模板与作用域链接起来。这会轮流调用每一个指令的链接函数，让每一个指令都能对DOM注册监听事件，和建立对作用域的的监听。 <br/>			3，这样最后就形成了作用域的DOM的动态绑定。任何一个作用域的改变都会在DOM上体现出来。						<!--					Angular编译器通过查询HTML中的directives处理DOM，处理结果是一个与scope model组合并生成实时模版的链接函数，					回调这个链接函数，就可以实现一个一直更新的view，而不需要重新拼接model与template。					首先浏览器会用它的标准API将HTML解析成DOM。 你需要认清这一点，因为我们的模板必须是可被解析的HTML。					这是AngularJS和那些“以字符串为基础而非以DOM元素为基础的”模板系统的区别之处。					DOM的编译是有$compile方法来执行的。 这个方法会遍历DOM并找到匹配的指令。					一旦找到一个，它就会被加入一个指令列表中，这个列表是用来记录所有和当前DOM相关的指令的。 					一旦所有的指令都被确定了，会按照优先级被排序，并且他们的compile方法会被调用。 					指令的$compile()函数能修改DOM结构，并且要负责生成一个link函数（后面会提到）。					$compile方法最后返回一个合并起来的链接函数，这是链接函数是每一个指令的compile函数返回的链接函数的集合。			<p>好处 @2 双向绑定更加容易</p>										<span>												AngualrJs既然更像是MVVM的实现，如果就做到这些，那么TA也没有特别之处。 但事实上AngularJs的HTML模板 + 双向绑定的实现更简洁经典：<br/>										</span>																				<p>好处 @ 1 ...</p>								<span>										Angular的这个处理方式，产生了一个稳定的DOM。这意味着在DOM元素的生命周期里，一直与某model的实例绑定着，这个关系不会发生改变。										这也意味着代码可以保持对某DOM对象的引用，对其注册事件函数，并且这个引用不会被模版数据合并所销毁。<br/><br/>								</span>						-->										<h4>How AngularJS Starts up in your browser?</h4>					<!--					http://angularjs.cn/A00q					-->					<!--					<!---					<pre>					<html lang="zh-cn" ng-app>					<head>					<meta charset="UTF-8">					<title>Hello Kitty!</title>					<style type="text/css">					.ng-cloak {					display: none;					}					</style>					</head>					<body>					<div ng-init="name='Kitty'">Hello {{name}}!</div>					<script src="../angular-1.0.1.js" type="text/javascript"></script>					</body>					</html>					</pre>					-->					<img src="./img/startup.png"/>					下面描述angular是如何启动的（参考图表与下面的例子）：					1. 浏览器加载HTML，将HTML标签转换为DOM对象；					2. 浏览器加载angular.js的脚本；					3. Angular等待DOMContentLoaded事件；					4. Angular寻找ng-app这个用于指定应用边界范围的directive；					5. 如果ng-app有指定module（也许是ng-app=”SomeApp”），将被用作配置$injector；					6. $injector用于创建$compile服务（service）以及$rootScope；					7. $compile服务用作“编译”（有点像遍历，然后做一点神秘的事情）DOM，并将其与对应的$rootScope连接。					8. ng-init 这个directive在对应的scope中创建name属性并对其赋予”Kitty”值；					9. 将“{{name}}”的值插入(interpolates)到表达式中，最终显示”Hello Kitty!”。														<h4>HTML编译器——$Compiler</h4>					<!--					Compiler作为Angular的一个服务（Service），负责遍历DOM结构，寻找属性。编译过程分成两个阶段：					1. 编译（Compile）：遍历DOM节点树，收集所有directives。返回结果是一个链接函数（linking function）。					2. 链接（Link）：将directives绑定到一个作用域（scope）中，创建一个实况视图（live view）。在scope中的任何改变，将会在视图中得到体现（更新视图）；任何用户对模版的活动（改变），将会体现在scope model中（双向绑定）。这使得scope model能够反映正确的值。								一些directives，诸如ng-repeat，会为每一个在集合（collection）中的元素复制一次特定的元素（组合）。编译和链接两个阶段，使性能得以提升。因为克隆出来的模版(template)只需要编译一次，然后为每一个集合中的元素进行一次链接（类似模版缓存）。					-->											在模版linking的阶段，directive在scope中设置$watch表达式。$watch让directive能够得知属性的变化，使得directive将更新后的值渲染到DOM中。													Demo			<!--  											下面解释例子“Hello Kitty”(-_-!)是如何在用户在文本框输入文本时实现数据绑定(data-binding)效果。					<pre>					<html lang="zh-cn" ng-app>					<head>					<meta charset="UTF-8">					<title>Hello Kitty!</title>					<style type="text/css">					.ng-cloak {					display: none;					}					</style>					</head>					<body>					<input ng-model="name" class="ng-cloak"/>					<p>Hello {{name}}!</p>					<script src="../angular-1.0.1.js" type="text/javascript"></script>					</body>					</html>					</pre>					1. 编译阶段(compilation phase)：		a) ng-model和input directive在<input>中版定keydown事件监听器。		b) {{name}}占位符（interpolation，不知道怎么翻译）（表达式）设置一个$watch以便在name发生改变时有所响应。2. 执行阶段(runtime phase)：			a) 在inut控件中按下”X”按钮，让浏览器触发一个keydown事件；			b) input directive捕捉到文本框值的改变，然后调用$apply(“name = ‘X’;”)，在angular execution context中更新应用的model。			c) Angluar将 “name = ‘X’;”应用在model中。(model发生改变)			d) $digest loop开始			e) $watch list检测到name的值被改变了，然后再次解析{{name}}表达式，然后更新DOM。			f) Angulart退出(angular) execution context，再依次退出keydown事件以及javascript execution context；			g) 浏览器重绘视图，更新字符。								-->																Factory method工厂函数   与 $Injector					http://angularjs.cn/A00r					<!--					http://www.cnblogs.com/lcllao/archive/2012/09/07/2671227.html					<img src="./img/Module & Injector.png"/>					Injector是一个服务定位器。每一个Angular应用，都会有一个单独的injector。Injector提供一个通过名称查找对象实例的途径。Injector会在内部cache中保持所有对象实例，所以重复调用相同的名称时，返回的都是同一个对象实例。如果对象不存在，那么它会请求实例工厂（instance factory）去创建一个新实例。					Module是一个配置injector的实例工厂的方法，被称为”provider”。					但是injector的真正牛X的地方在于它可以用于调用方法和”instantiate” type。这个美妙的特性是允许method和types请求他们所依赖的资源，而不是寻找他们。					注意，我们唯一需要写的，就是我们的function，在function的arguments中列出方法依赖的资源即可！当angular调用function时，他会使用”call”方法，自动填充function agruments。					留意下面的例子中是如何在constructor中列出依赖的。当ng-controller实例化controller时，将自动提供所依赖的资源。没有必要去创建、寻找、创建injector引用来加载依赖资源。					-->					<!--										工厂函数是用来创建指令的。它只会被调用一次：就是当编译器第一次匹配到相应指令的时候。你可以在其中进行任何初始化的工作。调用它时使用的是 $injector.invoke ， 所以它遵循所有注入器的规则。					-->			什么是Event Loop					<!--										http://www.ruanyifeng.com/blog/2013/10/event_loop.html-->					<!--					<img src="./img/startup.png"/>					这图表和后面的例子，描述了angular如何通过浏览器event-loop（所有的时间处理函数，以及timer执行的函数，会排在一个queue结构中，利用一个无限的循环，不断从queue中取出函数来执行，这个就是event-loop。来自http://wiki.nodejs.tw/nodejs_from_scratch/javascript-yunodejs/2-1-event-loop）来进行交互。					1. 浏览器event-loop等待事件到来。事件来自于用户交互（DOM events）、timer事件（setTimeout）、network事件（服务端响应，XHR之类）；					2. 事件回调函数开始执行。这里进入javascript上下文（context）。这回调函数可以修改DOM结构。					3. 当回调函数执行完毕后，浏览器退出javascript context，根据DOM的改变来重绘视图。					Angular通过创建自己的事件处理循环（event processing loop），修改了一般的javascript流（flow）。这将Javascript分割成传统的和Angular的执行上下文（execution context）。只要是在Angular execution context 里面执行的操作，都拥有angular data-binding、异常处理（exception handling）、属性监视（property watching）等能力。我们可以通过在javascript使用$apply()，进入Angular execution context。但要记住一点，在大多数（angular的）地方（如controllers、services），处理事件的directive会为你调用$apply。手动调用$apply的场景，一般是当你实现自定义事件处理函数，或者处理第三方库的回调的时候。					1. 通过调用scope.$apply(stimulusFn)进入angular execution context。stimulusFn就是我们想在angular execution context中执行的函数（含scope作为参数）或者angular合法的表达式。					2. Angular执行stimulusFn，这通常会改变应用的状态（application state）。					3. Angular进入$digest loop。这个loop由一个处理$evalAsync queue 和处理$watch list两个更小的循环组成。$digest loop会在model稳定之前保持迭代，即$evalAsync queue为空，而且$watch list没有检测到任何变化。					4. $evalAsync queue被用作安排必须跳出当前堆栈帧（堆栈帧指的是在堆栈中为当前正在运行的函数分配的区域（或空间）。传入的参数、返回地址（当这个函数结束后必须跳转到该返回地址。译注：即主调函数的断点处）以及函数所用的内部存储单元（即函数存储在堆栈上的局部变量）都在堆栈帧中。http://book.51cto.com/art/200804/70915.htm C.1.1  堆栈帧）之外，但在浏览器视图绘制之前的工作。这通常是通过使用setTimeout(0)来实现。但setTimeout(0)这方法，会导致缓慢，或者在每个事件处理完毕后，浏览器绘制视图时，出现视图闪烁（angular有没有去解决这个问题？如何解决？）。					5. $watch list是有可能在最近一次迭代中被修改的表达式的集合。如果(model)发生了改变，那么$watch 函数会被调用，从而达到对特定的DOM重新赋值的目标。					6. 一旦Angular $digest loop 完成了（之前3提到的情况），离开angular和javascript的context后，浏览器紧跟着就会去重绘DOM，以响应变化。					-->													<h4>AngularJs表达式</h4>angular不是通过javascript的eval()对表达式进行求值，而是内置的$parse服务解析执行。AngularJS的表达式解析环境的上下文是scope，而javascript则是window（严格模式evel的时候）。AngularJS需要通过$window访问global window对象。这样做的用意是避免意外访问了公共属性（global state，a common source of subtle bugs）。<!--controller和directive两者都与scope有引用，但它们两者之间没有（引用）。这样的安排，将controller从directive和DOM中隔离开来。-->								<br/><br/><br/><br/></section>