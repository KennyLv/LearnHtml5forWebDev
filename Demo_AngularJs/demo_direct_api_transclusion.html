<!DOCTYPE HTML><html lang="zh-cn"><head>		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">		<title>transclusion demo</title>		<meta name="author" content="Kenny"></head><body ng-app="testApp"><div  ng-controller="testCtrl">		<handsomeme>					<p>this is static info...</p>					{{name}}		</handsomeme> 				<hr/>				<thishandsomeme>					<p>this is static info...</p>					{{name}}		</thishandsomeme> 				</div><hr/><div  ng-controller="test1Ctrl">		<a-handsomeme>					<p>this is static info1...</p>					{{name}}		</a-handsomeme> </div>	<script type="text/javascript" src="../_Resource/angular_1.2.25/angular.min.js"></script><script type="text/javascript">		var app = angular.module('testApp', []);		/*		在AngularJS中你只在一个指令的模板中只能申明一个ng-tranclude。		*/		app.directive('handsomeme', function() {			  return {						restrict: 'EA',						transclude: true,						template :'<div>'								+'					<p>MaMa does not need to worry about my study anymore! </p>'								+'					<div ng-transclude>template info...</div>'								+'			</div> '			  }		});				app.directive('ahandsomeme', function() {			  return {						restrict: 'EA',						transclude: 'element',						template :'<div>'								+'					<p>MaMa does not need to worry about my study anymore! </p>'								+'					<div ng-transclude>template info1...</div>'								+'			</div> '			  }		});				/*		使用tranclude()的函数！！transclude()返回了嵌入部分的具体内容		*/		app.directive('thishandsomeme', function() {			  return {						restrict: 'EA',						transclude: true, // 'element' won't work here...						link : function(scope,elem,attrs,ctrl,transclude){//不使用ng-transclude								/*								var content = transclude();								console.log(content);								console.log(elem);								elem.append(content);								*/								/*								我们知道，在定义一个指令时，如果不显式声明scope，那么指令的作用域就是父作用域。								如果声明scope:true或者scope:{}，那么指令会生成一个自己的作用域，只不过一个原型继承，一个独立而已。								如果你使用transclusion，那么无论什么情绪，都会生成一个新的作用域，这个作用域直接原型继承于父作用域，它的地位和指令生成的作用域是一样的，二者属于并列的关系。																于是我们现在就能了解tranclude(scope,function(clone){})中的scope是什么意思了								默认情况下，如果我们简单使用translude()，那么作用域默认的是transclude生成的自作用域。								但是如果我们使用tranclude(scope,function(clone){})，那么作用域显然就是directive的作用域了。																*/								//transclude(scope.$parent,function(clone){ //使用父作用域								//transclude(scope.$parent.$new(),function(clone){ //使用新作用域								transclude(scope,function(clone){										console.log(clone);										console.log(elem);										elem.append(clone);								});														},						template :'<div>'								+'					<p>MaMa does not need to worry about my study anymore! </p>'								+'					<div>template info...</div>'								+'			</div> '			  }		});				app.controller("testCtrl",function($scope) {				$scope.name = "this is scope info...";		});				app.controller("test1Ctrl",function($scope) {				$scope.name = "this is scope info1...";		});		</script></body></html>