<!DOCTYPE html><html><head>		<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>		<title>Compile in Directive</title>		<meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">		</head><body ng-app="testModule">		<a href="http://www.ifeenan.com/angularjs/2014-09-04-%5B%E8%AF%91%5DNG%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84compile%E4%B8%8Elink%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/" target="_blank">		[译]ng指令中的compile与link函数解析		</a>		<br/>		<a href="http://segmentfault.com/q/1010000000664866" target="_blank">		angular指令的compile的参数(tElement,tAttrs)和link中的参数(scope,iElement,iAttrs)究竟有什么区别?		</a>		<!--		<script type="text/ng-template" id="text.html">				<div><h3 ng-transclude></h3></div>		</script>		-->		<div  id="testCtrl" >				<level-one>							<level-two>											<level-three> Hello  </level-three>							</level-two>				</level-one>								<!--					//compile与pre-link的执行顺序是依次执行的,但是post-link正好相反.					=======finished create directives=========					levelOne: compile									<level-two>												<level-three> Hello  </level-three>									</level-two>					levelTwo: compile									<level-three> Hello  </level-three>					levelThree: compile									Hello   										levelOne: pre link									<level-two>												<level-three> Hello  </level-three>									</level-two>					levelTwo: pre link									<level-three> Hello  </level-three>					levelThree: pre link 									Hello   					levelThree: post link									Hello   					levelTwo: post link 									<level-three> Hello  </level-three>					levelOne: post link 									<level-two>												<level-three> Hello  </level-three>									</level-two>				-->				<!--						// HERE THE ELEMENTS ARE STILL THE ORIGINAL TEMPLATE ELEMENTS						// COMPILE PHASE						// levelOne:    compile function is called on original DOM						// levelTwo:    compile function is called on original DOM						// levelThree:  compile function is called on original DOM						// AS OF HERE, THE ELEMENTS HAVE BEEN INSTANTIATED AND						// ARE BOUND TO A SCOPE						// (E.G. NG-REPEAT WOULD HAVE MULTIPLE INSTANCES)						// PRE-LINK PHASE						// levelOne:    pre link function is called on element instance						// levelTwo:    pre link function is called on element instance						// levelThree:  pre link function is called on element instance						// POST-LINK PHASE (Notice the reverse order)						// levelThree:  post link function is called on element instance						// levelTwo:    post link function is called on element instance						// levelOne:    post link function is called on element instance				-->		</div>				<script type="text/javascript" src="../_Resource/angular_1.2.25/angular.min.js"></script>		<script type="text/javascript">				//ng怎样处理指令其实是依赖于它定义时的对象属性的				//你可以定义一个compile或者一个link函数				//或者用pre-link和post-link函数来代替link.				//compile与pre-link的执行顺序是依次执行的,但是post-link正好相反.				/*				Compile						我们已经知道当ng发现dom构建完成时就开始处理dom.						所以当ng在遍历dom的时候,碰到level-one元素,从它的定义那里了解到,要执行一些必要的函数						因为compile函数定义在level-one指令的指令对象里,所以它会被调用并传递一个element对象作为它的参数						如果你仔细观察,就会看到,浏览器创建这个element对象时,仍然是最原始的html标记										在ng中,原始dom通常用来标识template element,所以我在定义compile函数参数时就用到了tElem名字,这个变量指向的就是template element.						一旦运行levelone指令中的compile函数,ng就会递归深度遍历它的dom节点,然后在level-two与level-three上面重复这些操作.				*/				/*				Post-link						深入了解pre-link函数之前,让我们来看看post-link函数.						如果你在定义指令的时候只使用了一个link函数,那么ng会把这个函数当成post-link来处理						当ng遍历完所有的dom并运行完所有的compile函数之后,就反向调用相关联的post-link函数.						dom现在开始反向,并执行post-link函数,因此,在之前这种反向的调用看起来有点奇怪,其实这样做是非常有意义的.												当运行包含子指令的指令post-link时,反向的post-link规则可以保证它的子指令的post-link是已经运行过的.						所以,当运行level-one指令的post-link函数的时候,我们能够保证level-two和level-three的post-link其实都已经运行过了.						这就是为什么人们都认为post-link是最安全或者默认的写业务逻辑的地方.						但是为什么这里的element跟compile里的又不同呢?						一旦ng调用过指令的compile函数,就会创建一个template element的element实例对象,并且为它提供一个scope对象,这个scope有可能是新实例,已经存在,子scope,独立的scope,						这些都得依赖指令定义对象里的scope属性值						所以当linking发生时,这个实例element以及scope对象已经是可用的了,并且被ng作为参数传递到post-link函数的参数列表中去.						所以post-link(pre-link)函数的element参数对象是一个element实例而不是一个template element.						所以上面例子里的输出是不同的				*/				/*				Pre-link									当写了一个post-link函数,你可以保证在执行post-link函数的时候,它的所有子级指令的post-link函数是已经执行过的.									在大部分的情况下,它都可以做的更好,因此通常我们都会使用它来编写指令代码.									然而,ng为我们提供了一个附加的hook机制,那就是pre-link函数,它能够保证在执行所有子指令的post-link函数之前.运行一些别的代码.									这句话是值得反复推敲的									pre-link函数能够保证在element实例上以及它的所有子指令的post-link运行之前执行.									所以它使的post-link函数反向执行是相当有意义的,它自己是原始的顺序执行pre-link函数									这也意为着pre-link函数运行在它所有子指令的pre-link函数之前,所以完整的理由就是:									一个元素的pre-link函数能够保证是运行在它所有的子指令的post-link与pre-link运行之前执行的.见下图				*/												function createDirective(name){							return function(){										return {													restrict: 'E',													/*													Compile 函数 -- 															使用compile函数可以改变原始的dom(template element),在ng创建原始dom实例以及创建scope实例之前.															可以应用于当需要生成多个element实例,只有一个template element的情况,															ng-repeat就是一个最好的例子,它就在是compile函数阶段改变原始的dom生成多个原始dom节点,然后每个又生成element实例.															因为compile只会运行一次,所以当你需要生成多个element实例的时候是可以提高性能的.															template element以及相关的属性是做为参数传递给compile函数的,不过这时候scope是不能用的:													*/													/**													* Compile function													* 													* @param tElem - template element													* @param tAttrs - attributes of the template element													*/													compile: function(tElem, tAttrs){																console.log(name + ': compile => ' + tElem.html());																return {																			/*																			Pre-link 函数																						使用pre-link函数可以运行一些业务代码在ng执行完compile函数之后,但是在它所有子指令的post-link函数将要执行之前.																						scope对象以及element实例将会做为参数传递给pre-link函数:																			*/																			/**																				* Pre-link function																				* 																				* @param scope - scope associated with this istance																				* @param iElem - instance element																				* @param iAttrs - attributes of the instance element																				*/																			pre: function(scope, iElem, iAttrs){																						console.log(name + ': pre link => ' + iElem.html());																			},																			/*																			Post-link 函数																					使用post-link函数来执行业务逻辑,在这个阶段,它已经知道它所有的子指令已经编译完成并且pre-link以及post-link函数已经执行完成.																					这就是被认为是最安全以及默认的编写业务逻辑代码的原因.																					scope实例以及element实例做为参数传递给post-link函数:																			*/																				/**																				* Post-link function																				* 																				* @param scope - scope associated with this istance																				* @param iElem - instance element																				* @param iAttrs - attributes of the instance element																				*/																			post: function(scope, iElem, iAttrs){																						console.log(name + ': post link => ' + iElem.html());																			}																}													}										}							}				}								var myModule = angular.module("testModule", []);				myModule.directive('levelOne', createDirective('levelOne'));				myModule.directive('levelTwo', createDirective('levelTwo'));				myModule.directive('levelThree', createDirective('levelThree'));				console.log("=======finished create directives=========");		</script></body></html>